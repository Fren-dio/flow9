import ds/reducer;
import material/material;
import material/material2tropic;
import formats/dom/assign;
import formats/dom/render;

/*
TODO:
- Debug why we get multiple B and C nodes
- Implement arrays formats/dom/assign
- Figure out how to do layout using HTML. Maybe we should not make divs, but other constructs for nesting?
- Implement editing, and incremental updates
*/

REditor(
	// The document is represented as a bunch of assignments. This works for any data structure
	document : Behaviour<[RAssign<?>]>,
	// Where are the cursors?
	cursor : Behaviour<[RLValue]>,
	// What leading path are we focusing on?
	focus : Behaviour<RLValue>,
	// What elements are selected?
	selected : Behaviour<[RLValue]>,
	// What elements are collapsed?
	collapsed : Behaviour<[RLValue]>,
	// How to edit a given value: Convert it to IXmlNode for use in the DOM
	editValue : (e : RAssign<?>, cursor : bool, readonly : bool, selected : bool) -> RAssign<IXmlNode>,
);

makeView(e : REditor<?>) -> Material {
	wh = make(WidthHeight(0.0, 0.0));

	keyListener = makeTKey(\ke -> {
		contains(["left", "right", "up", "down"], ke.utf)
		|| ke.shift || ke.ctrl || ke.alt
	});

	MInteractive([keyListener], 
		MConstruct([
				makeSubscribe(keyListener.pressed, \ke -> {
					if (ke.utf == "left") {
						// OK, move the cursor
					} else if (ke.utf == "right") {
						
					} else if (ke.utf == "up") {
						
					} else if (ke.utf == "down") {
						
					} else {
						
					}
				})
			],
			MInspect([IAvailable(wh)], 
				MHTMLStage(wh, \stage -> {
					// TODO: We could use some FRP array construct for the document to allow partial updates
					// instead of full updates
					us = fsubscribe(fselect3(e.document, e.cursor, e.selected, \assigns : [RAssign<?>], cursor, selected -> {
						// We run all the assignments
						iter(assigns,
							\a -> {
								xml = e.editValue(a, contains(cursor, a.lvalue), false, contains(selected, a.lvalue));
								htmlRAssign(stage, xml);
						});
						0;
					}), nop1);
					\ -> callList(us);
				})
			)
		)
	);
}

makeREditor(doc : [RAssign<?>], editFn : (e : RAssign<?>, cursor : bool, readonly : bool, selected : bool) -> RAssign<IXmlNode>) -> REditor {
	REditor(
		// The document
		make(doc),
		// The cursors
		make(if (doc != []) [doc[0].lvalue] else []),
		// Where the focus is
		make(RLeaf()),
		// Selection
		make([]),
		// What parts are collapsed
		make([]),
		// The function which will convert a node to HTML
		editFn
	);
}

jsonAssign2htmlAssign(l : RAssign<Json>, cursor : bool, readonly : bool, selected : bool) -> RAssign<IXmlNode> {
	RAssign(
		l.lvalue,
		viewRAssignHtml(l, cursor, readonly, selected)
	)
}

// This is called for all leafs
viewRAssignHtml(l : RAssign<Json>, cursor : bool, readonly : bool, selected : bool) -> IXmlNode {
	dom0 = switch (l.value) {
		JsonObject(members): eP("Object");
		JsonArray(value): eP("Array");
		JsonNull(): eP("null");
		JsonBool(v): eP(b2s(v));
		JsonDouble(v): eP(d2s(v));
		JsonString(s): eP(escapeHtml(s));
	};
	css0 = dom0.style;
	leftMargin = i2d(depthRLValue(l.lvalue)) * 8.0;
	css1 = CssValues(css0 with box = CssBox(css0.box with margin = CssMargin(css0.box.margin with left = CssLength(leftMargin, CssUnitEm()))));
	css = if (cursor) {
		// OK, this syntax sucks, but will work for now:
		CssValues(css1 with colors = CssColors(CssColorRgb(0, 180, 200)))
	} else css1;
	dom = EP(dom0 with style = css);
	dom2ixml(dom);
}

// TODO: We want a bunch of helpers for rlvalues

depthRLValue(l : RLValue) -> int {
	switch (l) {
		RLeaf(): 0;
		RLObject(__, rvalue): 1 + depthRLValue(rvalue);
		RLArrayPush(rvalue): 1 + depthRLValue(rvalue);
		RLArrayIndex(index, rvalue): 1 + depthRLValue(rvalue);
	}
}

main() {
	json1 = parseJsonSafe("
		{
			a: 0,
			b: [
				1,
				2,
				3
			],
			c: {
				d: true,
				e: null
			}
		}
	");

	editor = makeREditor(rreduceJson(json1, rarray()), jsonAssign2htmlAssign);
	mrender(
		makeMaterialManager([]), true,
		makeView(editor)
	);
	{}
}


/*

From the JSON, we get this sequence of RAssign<IXmlNode>:

RAssign(RLObject("a", RLeaf()), IXmlElement("p", [], [IXmlText("0")], []))
RAssign(RLObject("b", RLArrayPush(RLeaf())), IXmlElement("p", [], [IXmlText("1")], []))
RAssign(RLObject("b", RLArrayPush(RLeaf())), IXmlElement("p", [], [IXmlText("2")], []))
RAssign(RLObject("b", RLArrayPush(RLeaf())), IXmlElement("p", [], [IXmlText("3")], []))
RAssign(RLObject("c", RLObject("d", RLeaf())), IXmlElement("p", [], [IXmlText("true")], []))
RAssign(RLObject("c", RLObject("e", RLeaf())), IXmlElement("p", [], [IXmlText("null")], []))

That should correspond to

   <div id=".a"><p>0</p></div>
   <div id=".b">
        <div id=".b.0"><p>1</p></div>
        <div id=".b.1"><p>2</p></div>
        <div id=".b.2"><p>3</p></div>
   </div>
   <div id=".c">
       <div id=".c.d"><p>true</p></div>
       <div id=".c.e"><p>null</p></div>
   </div>

I.e. an lvalue object with "id" becomes <div id=path.id>, and RLArrayPush becomes <div id=path.index>.
RLLeaf is just text. The goal is that each id is unique.

Right now, there is a bug so we do not get this structure correctly.

The point is that with this approach, we can imperatively update the DOM tree efficiently, 
and rely on HTML to do a lot of layout for us.

TODO:

See we can maybe provide some kind of nesting structure:

RAssigns(
	assignments : [RAssign]
)

renderComap(p : Topic) -> RAssigns {
	html.body.p = renderTopic(p);
}

renderComap(Reducer<Topic>) -> Reducer<Html>;

Curator:

renderTopic(p : Topic) -> RAssigns {
	RAssigns(
		[
			table.tr[0] = RAssigns([
				td[0] = p.topic;
				rowspan = length(p.children());
				yalign = center;
			]),
			mapi(p.children(), \i, child -> {
				table.tr[i].td[1] = renderTopic(child);
			})
		]
	)
}

*/
