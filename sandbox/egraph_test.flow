import ds/egraph;
import formats/json/json;

// Pattern matching language
EPattern<?> ::= EPatternVar, EPatternTerm<?>;
	EPatternVar(id : string);
	EPatternTerm(head : ?, args : [EPattern<?>]);

EMatchResult(bindings : Tree<string, ?>, fail : bool);

// Does this pattern match this value at this point?
epatternMatch(acc : EMatchResult, e : EGraph<?>, term : ?, pattern : EPattern<?>) -> EMatchResult {
	switch (pattern) {
		EPatternVar(id): {
			mbind = lookupTree(acc.bindings, id);
			mbind ?? {
				// OK, already is bound. Check that it is consistent
				if (mbind == term) {
					acc
				} else {
					// otherwise, fail
					EMatchResult(acc with fail = true);
				}
			} : EMatchResult(acc with bindings = setTree(acc.bindings, id, term));
		}
		EPatternTerm(head, pargs): {
			split = e.splitChildren(term);
			if (split.first == head && length(split.second) == length(pargs)) {
				// OK, the head and # args match
				foldi(split.second, acc, \i, acc2, cterm : ? -> {
					epatternMatch(acc2, e, cterm, pargs[i]);
				});
			} else {
				// No match
				EMatchResult(acc with fail = true);
			}
		}
	}
}

//
// Pattern matching on the egraph
//

ENodeMatchResult(bindings : Tree<string, ENode<?>>, matchNode : ENode<?>, fail : bool);

makeENodeMatchResult(e : EGraph<?>) -> ENodeMatchResult {
	ENodeMatchResult(makeTree(), ENode(e.eclass.defaultValue, []), false)
}

epatternENodeMatch(acc : ENodeMatchResult, e : EGraph<?>, term : ENode<?>, pattern : EPattern<?>) -> ENodeMatchResult {
	switch (pattern) {
		EPatternVar(id): {
			mbind = lookupTree(acc.bindings, id);
			mbind ?? {
				// OK, already is bound. Check that it is consistent
				if (mbind == term) {
					acc
				} else {
					// otherwise, fail
					ENodeMatchResult(acc with fail = true);
				}
			} : ENodeMatchResult(acc with bindings = setTree(acc.bindings, id, term));
		}
		EPatternTerm(head, pargs): {
			if (!acc.fail && term.head == head && length(term.args) == length(pargs)) {
				// OK, the head and # args match
				foldi(term.args, acc, \i, acc2, class : int -> {
					if (acc2.fail) acc2
					else epatternEClassMatch(acc2, e, class, pargs[i]);
				});
			} else {
				// No match
				ENodeMatchResult(acc with fail = true);
			}
		}
	}
}

epatternEClassMatch(acc : ENodeMatchResult, e : EGraph<?>, class : int, pattern : EPattern<?>) -> ENodeMatchResult {
	nodes = getEClassNodes(e, class);
	epatternENodesMatch(acc, e, nodes, pattern)
}

// Check if any of these nodes match
epatternENodesMatch(acc : ENodeMatchResult, e : EGraph<?>, nodes : Set<ENode<?>>, pattern : EPattern<?>) -> ENodeMatchResult {
	pm : Maybe<PopSetResult<ENode<?>>> = popMaxSet(nodes);
	pm ?? {
		node = pm.value;
		rest = pm.rest;
		nodematch = epatternENodeMatch(acc, e, node, pattern);
		if (nodematch.fail) {
			// Didn't work. Try the next node
			epatternENodesMatch(acc, e, rest, pattern)
		} else {
			nodematch
		}
	} : {
		ENodeMatchResult(acc with fail = true);		
	}
}

main() {
	egraph : EGraph<Json> = makeEGraph(\json -> {
		switch (json : Json) {
			JsonNull(): Pair(json, []);
			JsonBool(v): Pair(json, []);
			JsonDouble(v): Pair(json, []);
			JsonString(s): Pair(json, []);
			JsonObject(members): {
				Pair(
					JsonObject(map(members, \m -> Pair(m.first, JsonNull()))),
					map(members, \m -> m.second)
				)
			}
			JsonArray(values): Pair(JsonArray([]), values);
		}
	});

//	null = addEExp(egraph, JsonNull());
	array1 = addEExp(egraph, JsonArray([JsonNull(), JsonDouble(2.0)]));
	array2 = addEExp(egraph, JsonArray([JsonNull(), JsonDouble(1.0)]));
	one = addEExp(egraph, JsonDouble(1.0));
	two = addEExp(egraph, JsonDouble(2.0));
	joinedDoubles = unionEClass(egraph, one, two);

	// OK, clean it up
	canonicalizeEGraph(egraph);	

	// Now, array1 & array2 should be equivalent
	array1Class = getEClassRoot(egraph, array1);
	array2Class = getEClassRoot(egraph, array2);
	println([array1Class, array2Class]);

	// Check pattern matching
	pattern = EPatternTerm(
		JsonArray([]), 
		[
			EPatternVar("elem1"),
			EPatternVar("elem2"),
		]
	);
	if (true) {
		// Concrete term based matching
		term = JsonArray([JsonNull(), JsonDouble(2.0)]);
		res = epatternMatch(EMatchResult(makeTree(), false), egraph, term, pattern);
		if (res.fail) {
			println("Could not match pattern")
		} else {
			traverseInOrder(res.bindings, \name, val -> {
				println(name + ": " + toString(val));
			})
		};
	}

	if (true) {
		pattern2 = EPatternVar("elem1");

		// OK, try a pattern match against a class
		res = epatternEClassMatch(makeENodeMatchResult(egraph), egraph, array1Class, pattern2);
		if (res.fail) {
			println("Could not match pattern")
		} else {
			traverseInOrder(res.bindings, \name, val -> {
				println(name + ": " + toString(val));
			})
		};
	}

	quit(0);
}
