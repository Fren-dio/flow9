import ds/tree;
import sys/concurrent;
import promise;

export {
	/*
	A scheduler for potentially asynchronous functions to run in multiple
	threads. The jobs support parents and dependencies.
	*/
	makeScheduler() -> Scheduler<?, ??>;
	// Prepare a scheduler to run asynchronously. Returns a 
	runScheduler(scheduler : Scheduler<?, ??>) -> () -> void;

	// Construct a new job id
	makeJobId(scheduler : Scheduler<?, ??>) -> int;
	// Schedule this job
	addJob(scheduler : Scheduler<?, ??>, job : Job<?, ??>) -> void;
	// Invalidate cache item
	invalidateJobCache(scheduler : Scheduler<?, ??>, cacheId : string) -> void;

	Scheduler(
		// What is a next id for a job?
		nextId : ref int,
		// From job id to the job
		jobs : ref Tree<int, Job<?, ??>>,
		// Priorities - list of jobs with a given priority
		// We only keep jobs that have dependencies solved here
		jobPriorities : ref Tree<int, [int]>,
		// Tracking the dependencies between jobs: Who depends on us?
		dependents : ref Tree<int, [int]>,
		// Our cache from cacheId to the kinds of job to the job id that made it when we have one
		results : ref Tree<string, Tree<string, int>>,
	);

	Job(
		// Unique id for the job
		id : int,
		// Lower is earlier
		priority : int,
		// Is this a part of a group of work? 0 if no parent
		parent : int, 
		// What other jobs do we depend on?
		dependencies : [int],
		// What is the kind of job?
		kind : string,
		// Any information about the job that the job would like to get
		context : ?,
		// Do we have a cache for the result? 0 is no, otherwise it is the unique hash id
		cacheId : string,
		// Persist the result on disk?
		persist : bool,
		// The function that runs the job when dependencies are done
		// If we have an older cached value, that is also given
		run : (Task<?, ??>) -> Promise<??, string>,
		// The result of the job after it has run
		result : ref Maybe<??>
	);

	// When we need to run a thing, this is what we get
	Task(
		s : Scheduler<?, ??>, 
		job : Job<?, ??>, 
		parents : [Job<?, ??>], 
		dependencies : [Job<?, ??>], 
		// Value from previous cache
		cache : Maybe<??>
	);
}

makeScheduler() -> Scheduler<?, ??> {
	Scheduler(
		// What is a next id for a job?
		ref 1,
		// From job id to the job
		ref makeTree(),
		// Priorities - list of jobs with a given priority
		ref makeTree(),
		// Tracking the dependencies between jobs
		ref makeTree(),
		// Results.
		ref makeTree(),
	);
}

runScheduler(scheduler : Scheduler<?, ??>) -> () -> void {
	println("Starting scheduler in a new thread");
	stop = ref false;
	concurrentAsyncCallback(
		// Task
		\threadId : string, callback : (int) -> void -> {
			if (^stop) {
				callback(0);
			} else {
				pingScheduler(scheduler);
			}
		},
		// onDone
		\res : int -> {
			println("Process complete");
		},
		// onFail
		\err : string -> {
			println("Failure: " + err);
		}
	);

	\ -> {
		// TODO: Also count jobs in motion and jobs that wait on stuff
		println("Cancelling " + i2s(sizeTree(^(scheduler.jobPriorities))) + " ready jobs");
		stop := true;
	}
}

pingScheduler(scheduler : Scheduler<?, ??>) -> void {
	p : TreePopResult<int, [int]> = popmin(^(scheduler.jobPriorities));
	switch (p) {
		EmptyPopResult(): {
			println("No job, so wait");
			timer(100, \ -> pingScheduler(scheduler));
		}
		PopResult(prio, tasks, rest): {
			if (length(tasks) > 0) {
				jobid = tasks[0];
				mjob = lookupTree(^(scheduler.jobs), jobid);
				mjob ?? {
					// Push the rest of the queue
					if (length(tasks) != 1) {
						scheduler.jobPriorities := setTree(^(scheduler.jobPriorities), prio, tail(tasks));
					} else {
						// We are done with this priority
						scheduler.jobPriorities := rest;
					}
					// OK, run the job
					runJob(scheduler, mjob);
				} : {
					println("Error: Job went missing");
					// We are done with this priority
					scheduler.jobPriorities := rest;
				}
			} else {
				// We are done with this priority
				scheduler.jobPriorities := rest;
			}
		}
	}
}

runJob(scheduler : Scheduler, job : Job<?, ??>) -> void {
	// Pull together the parents
	parents : [Job<?, ??>] = getJobParents(scheduler, [], job);
	// Pull together the dependencies
	deps : [Job<?, ??>] = filtermap(job.dependencies, \dep -> {
		lookupTree(^(scheduler.jobs), dep);
	});
	if (length(deps) != length(job.dependencies)) {
		println("Could not find dependendents");
	}
	task = Task(scheduler, job, parents, deps, getJobResult(scheduler, job));
	println("Running " + toString(job.context));
	promise : Promise<??, string> = job.run(task);
	doneP(promise, \res : ?? -> {
		println("Job done");
		job.result := Some(res);
		if (job.cacheId != "") {
			// Caching the result
			cachedTasks = lookupTreeDef(^(scheduler.results), job.cacheId, makeTree());
			scheduler.results := setTree(^(scheduler.results), 
				job.cacheId, setTree(cachedTasks, job.kind, job.id)
			);
		}
		println("TODO: If someone depends on us, put them in the job queue");
	}, \err -> {
		println(err);
		if (job.cacheId != "") {
			scheduler.results := removeFromTree(^(scheduler.results), job.cacheId);
		}
	})
}

getJobParents(scheduler : Scheduler<?, ??>, acc : [Job<?, ??>], job : Job<?, ??>) -> [Job<?, ??>] {
	if (job.parent == 0) acc
	else {
		mparent = lookupTree(^(scheduler.jobs), job.parent);
		mparent ?? {
			getJobParents(scheduler, arrayPush(acc, mparent), mparent)
		} : {
			println("Could not find parent " + i2s(job.parent));
			acc;
		}
	}
}

// See if we have a cached result
getJobResult(scheduler : Scheduler<?, ??>, job : Job<?, ??>) -> Maybe<??> {
	switch (^(job.result) : Maybe<??>) {
		None(): {
			if (job.cacheId == "") None()
			else {
				mcachedTasks = lookupTree(^(scheduler.results), job.cacheId);
				mcachedTasks ?? {
					cachedId : int = lookupTreeDef(mcachedTasks, job.kind, 0);
					mjob : Maybe<Job<?, ??>> = lookupTree(^(scheduler.jobs), cachedId);
					switch (mjob) {
						None(): None();
						Some(j): ^(j.result);
					}
				} : None();
			}
		}
		Some(r): Some(r);
	}
}

makeJobId(scheduler : Scheduler<?, ??>) -> int {
	atomicRefIntAddition(scheduler.nextId, 1)
}

addJob(scheduler : Scheduler<?, ??>, job : Job<?, ??>) -> void {
	if (job.dependencies != []) {
		resolved = map(job.dependencies, \d -> {
			//getJobResult(scheduler, d)
			0;
		});

		println("TODO: Add job dependencies to scheduler");
		scheduler.jobs := setTree(^(scheduler.jobs), job.id, job);
	} else {
		// TODO: Check if we already have this job and the cache is valid
		if (job.cacheId != "") {
			mexist = lookupTree(^(scheduler.results), job.cacheId);
			mexist ?? {
				// We have a cached value, so check that it is valid
				println("TODO: Check that the cache is ok")
			} : {
				// No cached result
				// This is ready for scheduling
				scheduler.jobs := setTree(^(scheduler.jobs), job.id, job);
				scheduler.jobPriorities := treePushToArrayValue(^(scheduler.jobPriorities), job.priority, job.id);
			}
		} else {
			// This is ready for scheduling
			scheduler.jobs := setTree(^(scheduler.jobs), job.id, job);
			scheduler.jobPriorities := treePushToArrayValue(^(scheduler.jobPriorities), job.priority, job.id);
		}
	}
}

invalidateJobCache(scheduler : Scheduler<?, ??>, cacheId : string) -> void {
	println("TODO: Invalidate cache entry");
}
