import material/extra/raymarching/raymarching_types;
import math/math;
import ds/arrayutils;

export {
	RMScene2RMIExp(obj : RMScene, simpleDistance : bool) -> Pair<RMIExp, Tree<int, RMIExp>>;
	RMLights2RMIExp(obj : RMLights) -> RMIExp;
	RMScene2RMIExpJS(obj : RMScene, acc : RMIXYZ) -> RMIExp;

	hexColor2RMI(color : int) -> RMIXYZ;
}

RMObjectCounter(
	objectId : int,
	textureId : int,
	topLevelObjects : Tree<int, RMIExp>
);

RMScene2RMIExp(obj : RMScene, simpleDistance : bool) -> Pair<RMIExp, Tree<int, RMIExp>> {
	resultExp = RMScene2RMIExp0(obj, RMIXYZ(0., 0., 0.), Pair(RMIXYZ(1., 1., 1.), 0.0), RMObjectCounter(0, 0, makeTree()), true, simpleDistance, false);
	Pair(resultExp.second, resultExp.first.topLevelObjects)
}

RMScene2RMIExp0(obj : RMScene, acc : RMIXYZ, material : Pair<RMIExp, double>, id : RMObjectCounter, topLevel : bool, simpleDistance : bool, innerLevel : bool) -> Pair<RMObjectCounter, RMIExp> {
	switch(obj) {
		RMCompositeObject(object, name, color, materialProperties, position): {
			compositeObject = RMSTranslate(RMMaterial(object, color, materialProperties), position);
			RMScene2RMIExp0(compositeObject, acc, material, id, topLevel, simpleDistance, innerLevel);
		};
		RMPrimitive(): {
			wrapFn = if (simpleDistance) \e -> Pair(RMObjectCounter(id.objectId + 1, id.textureId, id.topLevelObjects), e) else \e -> addColorToRMIExp(e, id, material, innerLevel);
			wrapFn(RMPrimitive2RMIExp(obj, acc));
		}
		RMSTranslate(object, d): RMScene2RMIExp0(object, addRMIXYZ(acc, RMCoordinate2RMIXYZ(d)), material, id, topLevel, simpleDistance, innerLevel);
		RMUnion2(object1, object2): {
			exp1 = RMScene2RMIExp0(object1, acc, material, id, topLevel, simpleDistance, innerLevel);
			exp2 = RMScene2RMIExp0(object2, acc, material, exp1.first, topLevel, simpleDistance, innerLevel);
			Pair(exp2.first, RMICall(RMIFn(if (simpleDistance) "min" else "minOI"),
				[
					exp1.second,
					exp2.second,
				]
			))
		};
		RMUnion(objects): {
			if (length(objects) > 0 ) {
				exp1 = RMScene2RMIExp0(objects[0], acc, material, id, topLevel, simpleDistance, innerLevel);
				fold(tail(objects), exp1, \acc2, obj2 -> {
					exp2 = RMScene2RMIExp0(obj2, acc, material, acc2.first, topLevel, simpleDistance, innerLevel);
					Pair(exp2.first, RMICall(RMIFn(if (simpleDistance) "min" else "minOI"),
						[
							acc2.second,
							exp2.second,
						]
					))
				})
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSmoothUnion(objects, k): {
			if (length(objects) > 0 ) {
				makeSmoothExp = \cond -> {
					initExp = RMScene2RMIExp0(objects[0], acc, material, id, false, simpleDistance, cond);
					fold(tail(objects), initExp, \acc2, obj2 -> {
						exp2 = RMScene2RMIExp0(obj2, acc, material, acc2.first, false, simpleDistance, cond);
						Pair(exp2.first, RMICall(
							RMIFn(if (simpleDistance) "opSmoothUnion" else if(cond) "minOIS" else "minOISR"),
							concat(
								[acc2.second, exp2.second, RMIDouble(k)],
								if (!simpleDistance && cond) [RMIP(), RMIVar("normal")] else []
							)
						))
					});
				}
				resultExp = makeSmoothExp(false);
				resultExpI = makeSmoothExp(true);
				if (topLevel) Pair(
					RMObjectCounter(resultExp.first with topLevelObjects = setTree(resultExp.first.topLevelObjects, id.objectId, resultExpI.second)),
					resultExp.second
				) else resultExp
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMMaterial(object, color, materialProperties): {
			reflectivness = getValue(extractStruct(materialProperties, RMReflect(make(0.))).mixCoef);

			switch(color) {
				RMTexture(texture, parameters): RMScene2RMIExp0(
					object,
					acc,
					Pair(
						RMICall(
							RMIFn("getTextureColor"),
							[
								RMIP(),
								RMIVar("normal"),
								RMIVar(formatString("textureParameters[%1]", [i2s(id.textureId)])),
								RMIVar(formatString("textures[%1]", [i2s(id.textureId)]))
							]
						),
						reflectivness
					),
					id,
					topLevel,
					simpleDistance,
					innerLevel
				);
				RMColor(col): RMScene2RMIExp0(
					object,
					acc,
					Pair(hexColor2RMI(getValue(col)), reflectivness),
					id,
					topLevel,
					simpleDistance,
					innerLevel
				);
			}
		}
		RMEmpty(): Pair(id, RMIEmpty());
	}
}

RMPrimitive2RMIExp(obj : RMPrimitive, acc : RMIXYZ) -> RMIExp {
	switch(obj) {
		RMSphere(radius): RMICall(RMIOp("-"), [
			RMICall(RMIFn("length"), [
				RMICall(RMIOp("-"), [RMIP(), acc]),
			]),
			RMIDouble(radius)
		]);
		RMPlane(normal): RMICall(RMIFn("dot"), [
			RMICall(RMIOp("-"), [RMIP(), acc]),
			RMICall(RMIFn("normalize"), [
				RMCoordinate2RMIXYZ(normal)
			])
		]);
		RMBox(box): RMICall(RMIFn("sdBox"), [
			RMICall(RMIOp("-"), [RMIP(), acc]),
			RMCoordinate2RMIXYZ(box)
		]);
		RMRoundBox(box, radius): RMICall(RMIFn("sdRoundBox"), [
			RMICall(RMIOp("-"), [RMIP(), acc]),
			RMCoordinate2RMIXYZ(box),
			RMIDouble(radius)
		]);
		RMBoxFrame(box, thickness): RMICall(RMIFn("sdBoxFrame"), [
			RMICall(RMIOp("-"), [RMIP(), acc]),
			RMCoordinate2RMIXYZ(box),
			RMIDouble(thickness)
		]);
		RMTorus(revolutionRadius, tubeRadius): RMICall(RMIFn("sdTorus"), [
			RMICall(RMIOp("-"), [RMIP(), acc]),
			RMICall(RMIFn("vec2"), [RMIDouble(revolutionRadius), RMIDouble(tubeRadius)])
		]);
		RMCappedTorus(revolutionRadius, tubeRadius, percent): RMICall(RMIFn("sdCappedTorus"), [
			RMICall(RMIOp("-"), [RMIP(), acc]),
			RMICall(RMIFn("vec2"), [RMIDouble(sin(PI * percent)), RMIDouble(cos(PI * percent))]),
			RMIDouble(revolutionRadius),
			RMIDouble(tubeRadius)
		]);
		RMCylinder(height, radius): RMICall(RMIFn("sdCappedCylinder"), [
			RMICall(RMIOp("-"), [RMIP(), acc]),
			RMIDouble(height),
			RMIDouble(radius)
		]);
		RMRoundedCylinder(height, radius, radiusRounded): RMICall(RMIFn("sdRoundedCylinder"), [
			RMICall(RMIOp("-"), [RMIP(), acc]),
			RMIDouble(radius / 2.),
			RMIDouble(radiusRounded),
			RMIDouble(height)
		]);
	}
}

RMLights2RMIExp(obj : RMLights) -> RMIExp {
	RMLights2RMIExp0(obj, RMIXYZ(0., 0., 0.), RMIXYZ(1., 1., 1.))
}

RMLights2RMIExp0(obj : RMLights, acc : RMIXYZ, color : RMIExp) -> RMIExp {
	switch(obj) {
		RMCompositeLight(size, name, col, position): {
			compositeObject = RMLTranslate(RMLightMaterial(RMLight(size), col), position);
			RMLights2RMIExp0(compositeObject, acc, color);
		};
		RMLTranslate(object, d): RMLights2RMIExp0(object, addRMIXYZ(acc, RMCoordinate2RMIXYZ(d)), color);
		RMLightMaterial(object, col): {
			RMLights2RMIExp0(
				object,
				acc,
				hexColor2RMI(getValue(col.color)),
			);
		}
		RMLight(size): RMICall(RMIOp("*"),
			[
				RMICall(RMIFn("getLight"), [
					RMIP(),
					RMIVar("rayDirection"),
					acc,
					color,
					RMIVar("normal"),
					RMIDouble(size)
				]),
				color
			]
		);
		RMPlus(object1, object2): {
			exp1 = RMLights2RMIExp0(object1, acc, color);
			exp2 = RMLights2RMIExp0(object2, acc, color);
			RMICall(RMIOp("+"),
				[
					exp1,
					exp2,
				]
			)
		};
		RMEmpty(): RMIEmpty();
	}
}


RMScene2RMIExpJS(obj : RMScene, acc : RMIXYZ) -> RMIExp {
	switch(obj) {
		RMCompositeObject(object, name, color, materialProperties, position): {
			compositeObject = RMSTranslate(RMMaterial(object, color, materialProperties), position);
			RMScene2RMIExpJS(compositeObject, acc);
		};
		RMSphere(radius): RMICall(RMIOp("-"), [
			RMICall(RMIFn("glm.length"), [
				RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [acc]))
			]),
			RMIDouble(radius)
		]);
		RMPlane(normal): RMICall(RMIFn("glm.dot"), [
			RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [acc])),
			RMICall(RMIFn("glm.normalize"), [
				RMCoordinate2RMIXYZ(normal)
			])
		]);
		RMBox(box): RMICall(RMIFn("sdBox"), [
			RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [acc])),
			RMCoordinate2RMIXYZ(box)
		]);
		RMRoundBox(box, radius): RMICall(RMIFn("sdRoundBox"), [
			RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [acc])),
			RMCoordinate2RMIXYZ(box),
			RMIDouble(radius)
		]);
		RMBoxFrame(box, thickness): RMICall(RMIFn("sdBoxFrame"), [
			RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [acc])),
			RMCoordinate2RMIXYZ(box),
			RMIDouble(thickness)
		]);
		RMTorus(revolutionRadius, tubeRadius): RMICall(RMIFn("sdTorus"), [
			RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [acc])),
			RMICall(RMIFn("glm.vec2"), [RMIDouble(revolutionRadius), RMIDouble(tubeRadius)])
		]);
		RMCappedTorus(revolutionRadius, tubeRadius, percent): RMICall(RMIFn("sdCappedTorus"), [
			RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [acc])),
			RMICall(RMIFn("glm.vec2"), [RMIDouble(sin(PI * percent)), RMIDouble(cos(PI * percent))]),
			RMIDouble(revolutionRadius),
			RMIDouble(tubeRadius)
		]);
		RMCylinder(height, radius): RMICall(RMIFn("sdCappedCylinder"), [
			RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [acc])),
			RMIDouble(height),
			RMIDouble(radius)
		]);
		RMRoundedCylinder(height, radius, radiusRounded): RMICall(RMIFn("sdRoundedCylinder"), [
			RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [acc])),
			RMIDouble(radius / 2.),
			RMIDouble(radiusRounded),
			RMIDouble(height)
		]);
		RMSTranslate(object, d): RMScene2RMIExpJS(object, addRMIXYZ(acc, RMCoordinate2RMIXYZ(d)));
		RMUnion2(object1, object2): RMICall(RMIFn("Math.min"),
			[
				RMScene2RMIExpJS(object1, acc),
				RMScene2RMIExpJS(object2, acc),
			]
		);
		RMUnion(objects): {
			if (length(objects) > 0 ) {
				exp1 = RMScene2RMIExpJS(objects[0], acc);
				fold(tail(objects), exp1, \acc2, obj2 -> {
					exp2 = RMScene2RMIExpJS(obj2, acc);
					RMICall(RMIFn("Math.min"),
						[
							acc2,
							exp2,
						]
					)
				})
			} else {
				RMIEmpty();
			}
		};
		RMSmoothUnion(objects, k): {
			if (length(objects) > 0 ) {
				exp1 = RMScene2RMIExpJS(objects[0], acc);
				fold(tail(objects), exp1, \acc2, obj2 -> {
					exp2 = RMScene2RMIExpJS(obj2, acc);
					RMICall(RMIFn("opSmoothUnion"),
						[
							acc2,
							exp2,
							RMIDouble(k)
						]
					)
				})
			} else {
				RMIEmpty();
			}
		};
		RMMaterial(object, color, materialProperties): RMScene2RMIExpJS(object, acc);
		RMEmpty(): RMIEmpty();
	}
}

RMCoordinate2RMIXYZ(c : RMCoordinate) -> RMIXYZ {
	switch(c) {
		RMXYZ(x, y, z): RMIXYZ(x, y, z);
		RMXY(x, y): RMIXYZ(x, y, 0.);
		RMXZ(x, z): RMIXYZ(x, 0., z);
		RMYZ(y, z): RMIXYZ(0., y, z);
		RMX(x): RMIXYZ(x, 0., 0.);
		RMY(y): RMIXYZ(0., y, 0.);
		RMZ(z): RMIXYZ(0., 0., z);
	}
}

addRMIXYZ(c1 : RMIXYZ, c2 : RMIXYZ) -> RMIXYZ {
	RMIXYZ(c1.x + c2.x, c1.y + c2.y, c1.z + c2.z)
}

addColorToRMIExp(exp : RMIExp, id : RMObjectCounter, color : Pair<RMIExp, double>, innerLevel : bool) -> Pair<RMObjectCounter, RMIProperty> {
	plainColor = switch (color.first) {
		RMIXYZ(x, y, z): Some(color.first);
		default: None();
	}
	isTexture = switch (color.first) {
		RMICall(fn, args): switch(fn) {
			RMIOp(__): false;
			RMIFn(fnName): fnName == "getTextureColor";
		};
		default: false;
	}
	Pair(
		RMObjectCounter(
			id.objectId + 1,
			id.textureId + b2i(isTexture),
			id.topLevelObjects
		),
		RMIProperty(
			RMICall(
				RMIFn("ObjectInfo"),
				[
					exp,
					RMIInt(id.objectId),
					RMIInt(if (isTexture) id.textureId else -1),
					RMIBool(true),
					RMICall(
						RMIFn("Material"),
						[
							eitherMap(plainColor, \__-> RMIVar(formatString("color[%1]", [i2s(id.objectId - id.textureId)])), if (!innerLevel) RMIXYZ(0., 0., 0.) else color.first),
							RMIVar(formatString("reflectiveness[%1]", [i2s(id.objectId)]))
						]
					)
				]
			),
			id.objectId,
			eitherMap(plainColor, \__-> RMIEmpty(), color.first),
		)
	)
}

hexColor2RMI(color : int) -> RMIXYZ {
	RMIXYZ(i2d(color/0x10000)/255., i2d(color/0x100%0x100)/255., (i2d(color%0x100)/255.))
}