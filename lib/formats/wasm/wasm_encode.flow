import formats/wasm/wasm_types;
import ds/array;
import math/bits;
import text/binary;

// The reference is this one:
// https://webassembly.github.io/spec/core/binary/index.html

// This is nice: https://mbebenita.github.io/WasmExplorer/
export {
	wasmModule2bytes(m : WasmModule) -> [int];
}

//
// Module
//

wasmModule2bytes(m : WasmModule) -> [int] {
	sections = \s -> fold(s, [], \acc, ss -> {
		concat(acc, wasmSection2bytes(ss))
	});
	concatA([
		[	// Magic
			0x00, 0x61, 0x73, 0x6d, 
			// Version
			0x01, 0x00, 0x00, 0x00,
		],
		sections(m.custom1),
		sections(m.types),
		sections(m.custom2),
		sections(m.imports),
		sections(m.custom3),
		sections(m.functions),
		sections(m.custom4),
		sections(m.tables), 
		sections(m.custom5),
		sections(m.memories),
		sections(m.custom6),
		sections(m.globals), 
		sections(m.custom7),
		sections(m.exports),
		sections(m.custom8),
		sections(m.starts), 
		sections(m.custom9),
		sections(m.elements), 
		sections(m.custom10),
		sections(m.datacounts),
		sections(m.custom11),
		sections(m.codes), 
		sections(m.custom12),
		sections(m.data),
		sections(m.custom13),
	])
}


//
// Values
//

WasmI32Const2bytes(val : WasmI32Const) -> [int] {
	wasmEncodeU32(val.val);
}

wasmI64Const2bytes(val : WasmI64Const) -> [int] {
	if (val.high != 0) {
		println("TODO: Support 64 bit integers");
	}
	wasmEncodeU32(val.low);
}

wasmF32Const2bytes(value : WasmF32Const) -> [int] {
	val = value.val;
	[
		bitAnd(val, 0xff),
		bitAnd(bitUshr(val, 8), 0xff),
		bitAnd(bitUshr(val, 16), 0xff),
		bitAnd(bitUshr(val, 25), 0xff),
	]
}

wasmF64Const2bytes(val : WasmF64Const) -> [int] {
	fold(subrange(s2a(toBinary(flow(val.val))), 3, 4), [], \acc, b -> {
		concat(acc, [bitAnd(b, 0xff), bitUshr(b, 8)])
	});
}


wasmName2bytes(name : string) -> [int] {
	wasmEncodeArray(string2utf8(name), \val -> [val])
}

//
// Types
//

wasmFuncType2bytes(t : WasmFuncType) -> [int] {
	// 0x70 #bytes(params) params #bytes(returns) returns
	concat3(
		[0x60],
		wasmEncodeArray(t.params, wasmValType2bytes),
		wasmEncodeArray(t.returns, wasmValType2bytes),
	)
}

wasmValType2bytes(v : WasmValType) -> [int] {
	switch (v) {
		WasmI32Type(): [0x7f];
		WasmI64Type(): [0x7e];
		WasmF32Type(): [0x7d];
		WasmF64Type(): [0x7c];
		WasmVecType(): [0x7b];
		WasmFuncRef(): [0x70];
		WasmExternRef(): [0x6f];
	}
}

wasmLimits2bytes(v : WasmLimits) -> [int] {
	if (v.maximum == 0) {
		concat(
			[ 0x00 ],
			wasmEncodeU32(v.minimum),
		)
	} else {
		concat3(
			[ 0x01 ],
			wasmEncodeU32(v.minimum),
			wasmEncodeU32(v.maximum),
		)
	}
}

wasmMemoryType2bytes(mem : WasmMemoryType) -> [int] {
	wasmLimits2bytes(mem.limits)
}

wasmTableType2bytes(t : WasmTableType) -> [int] {
	concat(
		wasmValType2bytes(t.reftype),
		wasmLimits2bytes(t.limits),
	)
}

wasmGlobalType2bytes(g : WasmGlobalType) -> [int] {
	concat(
		wasmValType2bytes(g.type),
		[b2i(g.ismutable)]
	)
}

//
// Sections
//

wasmSection2bytes(s : WasmSection) -> [int] {
	wrap = \id : int, bytes -> {
		concat3(
			[id],
			wasmEncodeU32(length(bytes)),
			bytes
		)
	}
	switch (s) {
		WasmCustomSection(name, bytes): wrap(0, concat(wasmName2bytes(name), bytes));
		WasmTypeSection(funcTypes): wrap(1, wasmEncodeArray(funcTypes, wasmFuncType2bytes));
		WasmImportSection(imports): wrap(2, wasmEncodeArray(imports, wasmImport2bytes));
		WasmFunctionSection(types): wrap(3, wasmEncodeArray(types, \type -> [type]));
		WasmTableSection(tables): wrap(4, wasmEncodeArray(tables, wasmTableType2bytes));
		WasmMemorySection(memories): wrap(5, wasmEncodeArray(memories, wasmMemoryType2bytes));
		WasmGlobalSection(globals): wrap(6, wasmEncodeArray(globals, wasmGlobal2bytes));
		WasmExportSection(exports): wrap(7, wasmEncodeArray(exports, wasmExport2bytes));
		WasmStartSection(start): wrap(8, [start]);
		WasmElementSection(elements): wrap(9, wasmEncodeArray(elements, wasmElement2bytes));
		WasmCodeSection(codes): wrap(10, wasmEncodeArray(codes, wasmCode2bytes));
		WasmDataSection(data): wrap(11, wasmEncodeArray(data, wasmData2bytes));
		WasmDataCountSection(count): wrap(12, [count]);
	}
}

wasmImport2bytes(i : WasmImport) -> [int] {
	desc = i.desc;
	concat3(
		wasmName2bytes(i.module),
		wasmName2bytes(i.name),
		switch (desc : WasmImportDesc) {
			WasmImportType(typeindex): [0, typeindex];
			WasmImportTable(table): concat([1], wasmTableType2bytes(table));
			WasmImportMemory(mem): concat([2], wasmMemoryType2bytes(mem));
			WasmImportGlobal(global): concat([3], wasmGlobalType2bytes(global));
		}
	)
}

wasmGlobal2bytes(g : WasmGlobal) -> [int] {
	concat(
		wasmGlobalType2bytes(g.type),
		wasmExpr2bytes(g.init)
	)
}

wasmExport2bytes(g : WasmExport) -> [int] {
	desc = g.desc;
	concat(
		wasmName2bytes(g.name),
		switch (desc) {
			WasmExportFunc(index): [0, index];
			WasmExportTable(table): [1, table];
			WasmExportMemory(memory): [2, memory];
			WasmExportGlobal(global): [3, global];
		}
	)
}

wasmElement2bytes(e : WasmElement) -> [int] {
	switch (e) {
		WasmElement0(offset, funindexes): concat3([0], wasmExpr2bytes(offset), wasmEncodeArray(funindexes, \in -> [in]));
		WasmElement1(funindexes): concat([1, 0x00], wasmEncodeArray(funindexes, \in -> [in]));
		WasmElement2(tableIndex, offset, funindexes): concat3([2, tableIndex], wasmExpr2bytes(offset), wasmEncodeArray(funindexes, \in -> [in]));
		WasmElement3(funindexes): concat([3, 0x00], wasmEncodeArray(funindexes, \in -> [in]));
		WasmElement4(offset, init): concat3([4], wasmExpr2bytes(offset), wasmEncodeArray(init, wasmExpr2bytes));
		WasmElement5(et, init): concat3([5], wasmValType2bytes(et), wasmEncodeArray(init, wasmExpr2bytes));
		WasmElement6(tableIndex, offset, et, init): concatA([[6, tableIndex], wasmExpr2bytes(offset), wasmValType2bytes(et), wasmEncodeArray(init, wasmExpr2bytes)]);
		WasmElement7(et, init): concat3([7], wasmValType2bytes(et), wasmEncodeArray(init, wasmExpr2bytes));
	}
}

wasmCode2bytes(c : WasmCode) -> [int] {
	code = concat(
		wasmEncodeArray(c.locals, wasmLocal2bytes),
		wasmExpr2bytes(c.code)
	);
	concat(
		wasmEncodeU32(length(code)),
		code
	)
}

wasmLocal2bytes(l : WasmLocal) -> [int] {
	concat(
		wasmEncodeU32(l.n),
		wasmValType2bytes(l.type)
	)
}

wasmData2bytes(d : WasmData) -> [int] {
	switch (d) {
		WasmData0(offset, bytes): concat3([0], wasmExpr2bytes(offset), bytes);
		WasmData1(bytes): concat([1], bytes);
		WasmData2(memory, offset, bytes): concat3([2, memory], wasmExpr2bytes(offset), bytes);
	}
}

//
// Instructions
//

wasmInstruction2bytes(i : WasmInstruction) -> [int] {
	println("TODO");
	[];
}

wasmExpr2bytes(e : WasmExpr) -> [int] {
	concat(
		concatA(
			map(e.instructions, wasmInstruction2bytes)
		),
		[ 0x0b ]
	)
}


//
// Helpers
//

wasmEncodeArray(a : [?], element2bytes : (?) -> [int]) -> [int] {
	byteChunks : [[int]] = map(a, element2bytes);
	concat(
		wasmEncodeU32(length(byteChunks)),
		concatA(byteChunks)
	)
}

wasmEncodeU32(i : int) -> [int] {
	if (0 <= i && i < 128) [i]
	else {
		concat(
			[bitOr(bitAnd(i, 0x7f), 0x80)],
			wasmEncodeU32(i / 128)
		)
	}
}
