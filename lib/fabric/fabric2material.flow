import fabric/env;
import material/material_ui;

export {
	fabric2material(env : FabricEnv, f : Fabric) -> Material;
}

fabric2material(env : FabricEnv, f : Fabric) -> Material {
	switch (f) {
		BLet(name, value, scope): {
			dyn = make(value);
			if (containsKeyTree(^(env.values), name)) {
				// Shadowing, and we make a new environment
				nenv = innerFabricEnv(env);
				setFabricValue(nenv, name, dyn);
				fabric2material(nenv, scope);
			} else {
				setFabricValue(env, name, dyn);
				fabric2material(env, scope);
			}
		}
		BCapture(name, value, scope): {
			dyn = captureFabricValue(env, name, value);
			fabric2material(env, scope);
		}
		BSelect(names, fn): {
			values = filtermap(names, \name -> getFabricDynamicValue(env, name));
			if (length(values) != length(names)) {
				missing = filter(names, \name -> !containsKeyTree(^(env.values), name));
				println("Error: Unknown values in BSelect " + toString(missing));
			}
			MSelect(fmerge(values), \vals -> {
				fabric = fn(env, vals);
				fabric2material(env, fabric);
			})
		}
		BBidirectional(a, b, a2b, b2a): {
			ma = getFabricDynamicValue(env, a);
			mb = getFabricDynamicValue(env, b);
			switch (ma) {
				None(): {
					println("Error: Unknown value for " + a);
					MText("Error", [])
				}
				Some(da): {
					switch (mb) {
						None(): {
							println("Error: Unknown value for " + b);
							MText("Error", [])
						}
						Some(db): {
							MConstruct([
								\ -> {
									bidirectionalLink(da, db, a2b, b2a)
								},
							], MEmpty())
						}
					}
				}
			}
		}
		BTimer(name, delta): {
			deltaInMs = round(delta * 1000.0);
			MConstruct([
				\ -> {
					setInterval(deltaInMs, \ -> {
						val = getFabricValueRequired(env, name, 0.0) + delta;
						nextFabricValue(env, name, val);
					})
				}], MEmpty()
			);
		}
		BContainerX(items, style): bcontainer2material(env, f);
		BTableX(rows, style): {
			println("TODO: Convert " + ellipsis(toString(f), 100) + " to Material");
			MText("TODO", [])
		}
		BMaterial(material): material;
		BGetEnv(fn): {
			fabric = fn(env);
			fabric2material(env, fabric);
		}
		BDialog(name, contents, style): {
			open = getFabricDynamicValueRequired(env, name, false);
			closeWhen = make(false);
			MGetManager(\man -> {
				MConstruct([
					makeSubscribe(open, \o -> {
						if (o) {
							next(closeWhen, false);
							mat = fabric2material(env, contents);
							ShowMDialog(man, closeWhen, style, mat);
						} else {
							nextDistinct(closeWhen, true);
						}
					})
				], MEmpty())
			})
		}
		BClickable(contents, onClick): {
			MClickable(fabric2material(env, contents), onClick)
		}
		BCheckBox(name, caption, style): {
			value = getOrMakeFabricValue(env, name, false);
			mat = fabric2material(env, caption);
			MCheckBox(mat, value, style)
		}
		BComposite(name, splitFn, renderFn, mergeFn): {
			value = getFabricDynamicValueRequired(env, name, 0);
			MSelect(value, \v -> {
				parts = splitFn(env, value);
				fab = renderFn(env, parts);
				mat = fabric2material(env, fab);
				MConstruct([
					makeSubscribe(fmerge(parts), \p -> {
						nv = mergeFn(env, p);
						nextDistinct(value, nv);
					})
				], mat);
			})
		}
	}
}

bcontainer2material(env : FabricEnv, b : BContainerX) -> Material {
	mitems = map(b.items, \t -> fabric2material(env, t));
	style = b.style;
	if (js) {
		wh = make(WidthHeight(0.0, 0.0));

		// TODO: Get available directly from clip
		MGetManager(\manager -> MInspect([IAvailable(wh)], 
			MHTMLStage(wh, \div -> {
				if (style.downwards) {
					setClipStyle(div, "display", "flex");
					setClipStyle(div, "flex-direction", "column");
					setClipStyle(div, "alignItems", "flex-start");
				} else if (style.group) {
					setClipStyle(div, "display", "grid");
				} else if (style.baseline) {
					setClipStyle(div, "display", "flex");
					setClipStyle(div, "flexDirection", "row");
					setClipStyle(div, "alignItems", "baseline");
				} else {
					setClipStyle(div, "display", "flex");
					setClipStyle(div, "flexDirection", "row");
					setClipStyle(div, "alignItems", "top");
				}

				disposers = mapi(mitems, \z, it -> {
					tr = material2tropic(manager, it);
					ot = optimizeTropic(resolveTropicCss(tr, emptyStylesheet));
					tacc = tropic2Acc(ot, makeTParentInfo(wh), emptyStylesheet, false);
					f = tacc.form;
					zorder = const([z]);
					r = renderFForm(optimizeFForm(f), zorder);
					d = attachFChildren(div, r.clips, r.disposers, r.capabilities).disposers;
					iter(r.clips, \cl -> {
						setClipStyle(cl, "position", "relative");

						// TODO: Update dynamically, skip if content has no fillers
						setClipStyle(cl, "minWidth", d2s(fgetValue(tacc.minWidth)) + "px");
						setClipStyle(cl, "maxWidth", d2s(fgetValue(tacc.maxWidth)) + "px");
						setClipStyle(cl, "minHeight", d2s(fgetValue(tacc.minHeight)) + "px");
						setClipStyle(cl, "maxHeight", d2s(fgetValue(tacc.maxHeight)) + "px");
					});
					d;
				})
				|> concatA;

				\ -> {
					applyall(disposers);
				}
			})
		))
	} else {
		if (style.downwards) {
			MLines(mitems)
		} else if (style.group) {
			MGroup(mitems)
		} else if (style.baseline) {
			MBaselineCols(mitems)
		} else {
			MCols(mitems);
		}
	}
}
