import fabric/env;
import fabric/table;
import fabric/css;
import material/material_ui;

export {
	fabric2material(env : FabricEnv, f : Fabric) -> Material;
	fabric2dom(manager : MaterialManager, stage : native, parent : native, env : FabricEnv, f : Fabric) -> () -> () -> void;
}

fabric2material(env : FabricEnv, f : Fabric) -> Material {
	switch (f) {
		BLet(name, value, scope): {
			dyn = make(value);
			if (containsKeyTree(^(env.values), name)) {
				// Shadowing, and we make a new environment
				nenv = innerFabricEnv(env);
				defineFab(nenv, name, dyn);
				fabric2material(nenv, scope);
			} else {
				defineFab(env, name, dyn);
				fabric2material(env, scope);
			}
		}
		BCapture(name, value, scope): {
			dyn = captureFabricValue(env, name, value);
			fabric2material(env, scope);
		}
		BSelect(names, fn): {
			values = filtermap(names, \name -> getFabDynM(env, name));
			if (length(values) != length(names)) {
				missing = filter(names, \name -> !containsKeyTree(^(env.values), name));
				println("Error: Unknown values in BSelect " + toString(missing));
			}
			MSelect(fmerge(values), \vals -> {
				fabric = fn(env, vals);
				fabric2material(env, fabric);
			})
		}
		BBidirectional(a, b, a2b, b2a): {
			ma = getFabDynM(env, a);
			mb = getFabDynM(env, b);
			switch (ma) {
				None(): {
					println("Error: Unknown value for " + a);
					MText("Error", [])
				}
				Some(da): {
					switch (mb) {
						None(): {
							println("Error: Unknown value for " + b);
							MText("Error", [])
						}
						Some(db): {
							MConstruct([
								\ -> {
									bidirectionalLink(da, db, a2b, b2a)
								},
							], MEmpty())
						}
					}
				}
			}
		}
		BTimer(name, delta): {
			deltaInMs = round(delta * 1000.0);
			MConstruct([
				\ -> {
					setInterval(deltaInMs, \ -> {
						val = getFab(env, name, 0.0) + delta;
						setFab(env, name, val);
					})
				}], MEmpty()
			);
		}
		BContainerX(items, style): bcontainer2material(env, f);
		BTableX(rows, style): {
			mrows = map(rows, \row -> {
				map(row, \c -> {
					fabric2material(env, c)
				})
			});
			btable2material(mrows, style);
		}
		BScroll(content, style): {
			mat = fabric2material(env, content);
			MScroll(mat, MFillXY(), style)
		}
		BMaterial(material): material;
		BGetEnv(fn): {
			fabric = fn(env);
			fabric2material(env, fabric);
		}
		BDialog(name, contents, style): {
			open = getFabDyn(env, name, false);
			closeWhen = make(false);
			MGetManager(\man -> {
				MConstruct([
					makeSubscribe(open, \o -> {
						if (o) {
							next(closeWhen, false);
							mat = fabric2material(env, contents);
							ShowMDialog(man, closeWhen, style, mat);
						} else {
							nextDistinct(closeWhen, true);
						}
					})
				], MEmpty())
			})
		}
		BClickable(contents, onClick): {
			MClickable(fabric2material(env, contents), onClick)
		}
		BCheckBox(name, caption, style): {
			value = getOrMakeFabricValue(env, name, false);
			mat = fabric2material(env, caption);
			MCheckBox(mat, value, style)
		}
		BInteractive(interactivity, contents): {
			mat = fabric2material(env, contents);
			MInteractive(interactivity, mat)
		}
		BComposite(name, splitFn, renderFn, mergeFn): {
			value = getFabDyn(env, name, 0);
			MSelect(value, \v -> {
				ienv = innerFabricEnv(env);
				parts = splitFn(env, v);
				values = map(parts, \p -> make(p));
				// Set up these values
				iteri(values, \i, pvalue -> {
					defineFab(ienv, name + i2s(i), pvalue);
				});
				fab = renderFn(ienv, parts);
				mat = fabric2material(ienv, fab);

				MConstruct([
					// TODO: This is wrong. We need behaviours for the parts
					makeSubscribe(fmerge(values), \p -> {
						nv = mergeFn(env, p);
						nextDistinct(value, nv);
					})
				], mat);
			})
		}
	}
}

bcontainer2material(env : FabricEnv, b : BContainerX) -> Material {
	style = b.style;
	if (js && !isUrlParameterTrue("force_material")) {
		wh = make(WidthHeight(0.0, 0.0));

		// TODO: Get available directly from clip
		MGetManager(\manager -> MInspect([IAvailable(wh)],
			MHTMLStage(wh, \stage -> {
				div = getClipNativeWidget(stage);
				fabric2dom(manager, stage, div, env, b)();
			})
		))
	} else {
		mitems = map(b.items, \t -> fabric2material(env, t));

		m = if (style.downwards) {
			MLines(mitems)
		} else if (style.group) {
			MGroup(mitems)
		} else if (style.baseline) {
			MBaselineCols(mitems)
		} else {
			MCols(mitems);
		};
		if (style.padding != BEdges(0.0, 0.0, 0.0, 0.0)) {
			MBorder(style.padding.left, style.padding.top, style.padding.right, style.padding.bottom, m)
		} else m;
	}
}

// TODO: Move away from DisplayObjects to plain DOM elements
fabric2dom(manager : MaterialManager, stage : native, parent : native, env : FabricEnv, f : Fabric) -> () -> () -> void {
	onError = \e -> {
		println(e);
		el = createElement("p");
		changeNodeValue(el, e);
		\ -> {
			appendChild(parent, el);
			\ -> {
				removeChild(parent, el);
			}
		}
	}
	renderMaterial : (Material) -> () -> () -> void = \m -> {
		renderMaterialToClip(manager, stage, parent, m);
	}
	switch (f) {
		BLet(name, value, scope): {
			dyn = make(value);
			if (containsKeyTree(^(env.values), name)) {
				// Shadowing, and we make a new environment
				nenv = innerFabricEnv(env);
				defineFab(nenv, name, dyn);
				fabric2dom(manager, stage, parent, nenv, scope);
			} else {
				defineFab(env, name, dyn);
				fabric2dom(manager, stage, parent, env, scope);
			}
		}
		BCapture(name, value, scope): {
			dyn = captureFabricValue(env, name, value);
			fabric2dom(manager, stage, parent, env, scope);
		}
		BGetEnv(fn): {
			fabric = fn(env);
			fabric2dom(manager, stage, parent, env, fabric);
		}
		BSelect(names, fn): {
			values = filtermap(names, \name -> getFabDynM(env, name));
			if (length(values) != length(names)) {
				missing = filter(names, \name -> !containsKeyTree(^(env.values), name));
				println("Error: Unknown values in BSelect " + toString(missing));
			}

			makeSubscribeUns(fmerge(values), \vals -> {
				fabric = fn(env, vals);
				[fabric2dom(manager, stage, parent, env, fabric)()];
			});
		}
		BBidirectional(a, b, a2b, b2a): {
			ma = getFabDynM(env, a);
			mb = getFabDynM(env, b);
			switch (ma) {
				None(): {
					onError("Error: Unknown value for " + a);
				}
				Some(da): {
					switch (mb) {
						None(): {
							onError("Error: Unknown value for " + b);
						}
						Some(db): {
							\ -> bidirectionalLink(da, db, a2b, b2a)
						}
					}
				}
			}
		}
		BTimer(name, delta): {
			deltaInMs = round(delta * 1000.0);
			\ -> setInterval(deltaInMs, \ -> {
				val = getFab(env, name, 0.0) + delta;
				setFab(env, name, val);
			});
		}
		BContainerX(items, style): {
			div = createElement("div");
			if (style.downwards) {
				setElementStyle(div, "display", "flex");
				setElementStyle(div, "flex-direction", "column");
				setElementStyle(div, "alignItems", "flex-start");
			} else if (style.group) {
				setElementStyle(div, "display", "grid");
			} else if (style.baseline) {
				setElementStyle(div, "display", "flex");
				setElementStyle(div, "flexDirection", "row");
				setElementStyle(div, "alignItems", "baseline");
			} else {
				setElementStyle(div, "display", "flex");
				setElementStyle(div, "flexDirection", "row");
				setElementStyle(div, "alignItems", "top");
			}
			setElementStyle(div, "position", "static");
			setElementStyle(div, "padding", bedge2css(style.padding));
			setElementStyle(div, "margin", bedge2css(style.margin));
			setElementStyle(div, "gap", "0");
			children = map(items, \t -> fabric2dom(manager, stage, div, env, t));
			\ -> {
				appendChild(parent, div);
				d = map(children, apply0);
				\ -> {
					removeChild(parent, div);
					applyall(d);
				}
			}
		}
		BTableX(rows, style): {
			table = createElement("table");
			setElementStyle(table, "position", "static");
			tbody = createElement("tbody");
			setElementStyle(tbody, "position", "static");
			appendChild(table, tbody);
			children = map(rows, \row -> {
				tr = createElement("tr");
				setElementStyle(tr, "position", "static");
				appendChild(tbody, tr);
				map(row, \c -> {
					td = createElement("td");
					setElementStyle(td, "position", "static");
					appendChild(tr, td);
					fabric2dom(manager, stage, td, env, c)
				})
			}) |> concatA;
			\ -> {
				appendChild(parent, table);
				d = map(children, apply0);
				\ -> {
					removeChild(parent, table);
					applyall(d);
				}
			}
		}
		BScroll(content, style): {
			div = createElement("div");
			setElementStyle(div, "overflow", "auto");
			setElementStyle(div, "position", "static");
			setElementStyle(div, "width", "100%");
			setElementStyle(div, "height", "100%");
			child = fabric2dom(manager, stage, div, env, content);
			\ -> {
				appendChild(parent, div);
				d = child();
				\ -> {
					removeChild(parent, div);
					d();
				}
			}
		}
		BMaterial(material): {
			renderMaterial(material);
		}
		BDialog(name, contents, style): {
			open = getFabDyn(env, name, false);
			closeWhen = make(false);
			makeSubscribe(open, \o -> {
				if (o) {
					next(closeWhen, false);
					// TODO: Use fabric2dom
					mat = fabric2material(env, contents);
					ShowMDialog(manager, closeWhen, style, mat);
				} else {
					nextDistinct(closeWhen, true);
				}
			});
		}
		BClickable(contents, onClick): {
			// TODO: Use fabric2dom
			renderMaterial(MClickable(fabric2material(env, contents), onClick));
		}
		BCheckBox(name, caption, style): {
			value = getOrMakeFabricValue(env, name, false);
			// TODO: Use fabric2dom
			mat = fabric2material(env, caption);
			renderMaterial(MCheckBox(mat, value, style));
		}
		BInteractive(interactivity, contents): {
			// TODO: Use fabric2dom when possible
			mat = fabric2material(env, contents);
			renderMaterial(MInteractive(interactivity, mat));
		}
		BComposite(name, splitFn, renderFn, mergeFn): {
			value = getFabDyn(env, name, 0);
			makeSubscribeUns(value, \v -> {
				ienv = innerFabricEnv(env);
				parts = splitFn(env, v);
				values = map(parts, \p -> make(p));
				// Set up these values
				iteri(values, \i, pvalue -> {
					defineFab(ienv, name + i2s(i), pvalue);
				});
				fab = renderFn(ienv, parts);

				[
					fabric2dom(manager, stage, parent, ienv, fab)(),
					makeSubscribe(fmerge(values), \p -> {
						nv = mergeFn(env, p);
						nextDistinct(value, nv);
					})()
				];
			});
		}
	}
}

renderMaterialToClip(manager : MaterialManager, stage : native, parent : native, material : Material) -> () -> () -> void {
	tr = material2tropic(manager, material);
	ot = optimizeTropic(resolveTropicCss(tr, emptyStylesheet));
	clipWH = make(WidthHeight(0.0, 0.0));
	tacc = tropic2Acc(ot, makeTParentInfo(clipWH), emptyStylesheet, false);
	zorder = const([]);
	\ -> {
		r = renderFForm(optimizeFForm(tacc.form), zorder);
		d = concat(
			attachFChildren(stage, r.clips, r.disposers, r.capabilities).disposers,
			if (length(r.clips) > 0) {
				clip = r.clips[0];
				setClipParentElement(clip, parent);
				updateClipWH = \ -> {
					rect = getClipBoundingClientRect(clip);
					if (length(rect) > 3) {
						next(clipWH, WidthHeight(rect[2], rect[3]));
					}
				}

				setClipStyle(clip, "position", "relative");

				[
					make3Subscribe(tacc.xFillers, tacc.minWidth, tacc.maxWidth, \xf, minW, maxW -> {
						setClipStyle(clip, "width", if (xf > 0.0) d2s(xf * 100.0) + "%" else "");
						setClipStyle(clip, "minWidth", if (xf > 0.0) d2s(minW) + "px" else "");
						setClipStyle(clip, "maxWidth", if (xf > 0.0) d2s(maxW) + "px" else "");
					})(),
					make3Subscribe(tacc.yFillers, tacc.minHeight, tacc.maxHeight, \yf, minH, maxH -> {
						setClipStyle(clip, "height", if (yf > 0.0) d2s(yf * 100.0) + "%" else "");
						setClipStyle(clip, "minHeight", if (yf > 0.0) d2s(minH) + "px" else "");
						setClipStyle(clip, "maxHeight", if (yf > 0.0) d2s(maxH) + "px" else "");
					})(),
					make2SubscribeUns(tacc.xFillers, tacc.yFillers, \xf, yf -> {
						if (xf > 0.0 || yf > 0.0) {
							updateClipWH();

							[
								addEventListener(clip, "resize", updateClipWH)
							]

						} else {
							[]
						}
					})()
				]
			} else []
		);
		\ -> applyall(d);
	}
}
