import ds/bitvector;
import math/math;
import text/blueprint;

// Paper describing this here:
// https://www.dcc.uchile.cl/TR/2009/TR_DCC-20090429-005.pdf

// With implementation here: 
// https://github.com/simongog/sdsl-lite/blob/master/include/sdsl/k2_tree.hpp

// And another in Rust here:
// https://github.com/GGabi/k2_tree/blob/master/src/tree/datastore.rs

// TODO: The problem is to figure out what the leave offset is when we
// go east and south. In these cases, we need to count the number of 0s
// in the nodes so we know how much we do NOT have to move forward.

// The latest paper describes how to make it simpler to solve: 
// Have an array of internal nodes for each level.
// TODO: Adjust the leaves offset correspondingly.

// At first, we do a k=2 implementation just to get it working

QuadI(
    // How high is the tree in levels? Each level contains *4 more nits
    height : int,
    // These are really just bits. These correspond to the nodes in lexicographic order, except for the leafes
    // If the value is 0, it means that all the leaves below this node are 0.
    nodes : [int],
	// These are really bits. The correspond to the nodes in lexicographic order of the tree,
	// but with a separate array for each level. The value is 0 when all leaves below are 0.
	levelNodes : [[int]],
    // These are really just bits. We keep groups of 4 bits for each leaves which is not 0
    leaves : [int],
    // Where does the leaf for each leaf quadrant begin in terms of index into leaves?
    leavesOffset : [int],
);

// Construct a compressed QuadTree for these bools
build1(matrix : [[int]]) -> QuadI {
    n = length(matrix);
    if (n <= 2) {
        xy = \x, y -> elementAt(elementAt(matrix, y, [0]), x, 0);
        leaves = [
                xy(0,0), xy(1, 0),
                xy(0,1), xy(1, 1)
            ];
        if (leaves == [0, 0, 0, 0]) {
            QuadI(1, [0], [[0]], [], [0]);
        } else {
            QuadI(1,
                [1], 
				[[1]],
                leaves
				,[0]
            );
        }
    } else {
        height = ceil(log(i2d(length(matrix))) / log(i2d(2)));
        step = pow(2, height);
        half = step / 2;
        nw = build1(map(subrange(matrix, 0, half), \row -> subrange(row, 0, half)));
        ne = build1(map(subrange(matrix, 0, half), \row -> subrange(row, half, half)));
        sw = build1(map(subrange(matrix, half, half), \row -> subrange(row, 0, half)));
        se = build1(map(subrange(matrix, half, half), \row -> subrange(row, half, half)));
        m = mergeQuadI(mergeQuadI(mergeQuadI(nw, ne), sw), se);
        QuadI(
            m.height + 1,
            concat(
                if (m.leaves == []) [0] else [1], 
                m.nodes
            ),
			concat(
				if (m.leaves == []) [[0]] else [[1]],
				m.levelNodes,
			),
            m.leaves,
            concat([0], m.leavesOffset)
        )
    }
}

mergeQuadI(left : QuadI, right : QuadI) -> QuadI {
    QuadI(
        left.height,
        concat(left.nodes, right.nodes),
		mapi(left.levelNodes, \i, ln -> {
			concat(ln, right.levelNodes[i])
		}),
        concat(left.leaves, right.leaves),
        concat(left.leavesOffset, map(right.leavesOffset, \o -> o + length(left.leaves)))
    )
}

// TODO: Implement this correctly. Call with height = 0, node = 0 and leavesOffset = 0
getQuadI(q : QuadI, height : int, node : int, leavesOffset : int, x : int, y : int, debug : bool) -> bool {
	if (debug) {
		println("Looking for " + i2s(x) + "," + i2s(y) + " at node offset " + i2s(node) + " and leaf " + i2s(leavesOffset) + " at height " + i2s(height));
	}
    // If the root is empty, we know it is false
	if (height + 1 == q.height) {
		if (debug) {
			println("We are here at " + i2s(leavesOffset + x + 2 * y));
		}
		elementAt(q.leaves, leavesOffset + x + 2 * y, 0) == 1;
	} else if (q.nodes[node] == 0) false
    else {
        half = pow(2, height + 1);
		step = half * 2;
        //half = step / 2;
        north = y < half;
        west = x < half;

        offset = if (north && west) {
            0
        } else if (north && !west) {
            // NE: Check if the NW is empty or not
            if (q.nodes[node + 1] == 0) 0 else step;
        } else if (!north && west) {
            if (q.nodes[node + 1] == 0) 0 else step
            + if (q.nodes[node + 2] == 0) 0 else step;
        } else {
            if (q.nodes[node + 1] == 0) 0 else step
            + if (q.nodes[node + 2] == 0) 0 else step
            + if (q.nodes[node + 3] == 0) 0 else step;
        };

		levelOffset = pow(4, height);
        newLeafOffset = q.leavesOffset[node + levelOffset];

		if (debug) {
			println(" with step " + i2s(step) + " and north " + b2s(north) + " and west " + b2s(west));
			println(" giving node " + i2s(node + levelOffset) + " leaf " + i2s(newLeafOffset));
		}

        getQuadI(q, 
			height + 1,
            node + levelOffset,
            newLeafOffset, 
			// We should fix these if we are east or south
			if (west) x else x - step, 
			if (north) y else y - step,
			debug
        );
    }
}

/*
        bool adj(idx_type i, idx_type j) const
        {
            if (k_t.size() == 0 && k_l.size() == 0)
                return false;
            size_type n = std::pow(k_k, k_height - 1);
            size_type k_2 = std::pow(k_k, 2);
            idx_type col, row;

            // This is duplicated to avoid an extra if at the loop. As idx_type
            // is unsigned and rank has an offset of one, is not possible to run
            // k_t_rank with zero as parameter at the first iteration.
            row = std::floor(i/static_cast<double>(n));
            col = std::floor(j/static_cast<double>(n));
            i = i % n;
            j = j % n;
            idx_type level = k_k * row + col;
            n = n/k_k;

            while (level < k_t.size()) {
                if (k_t[level] == 0)
                    return false;
                row = std::floor(i/static_cast<double>(n));
                col = std::floor(j/static_cast<double>(n));
                i = i % n;
                j = j % n;
                level = k_t_rank(level + 1) * k_2 + k_k * row + col;
                n = n/k_k;
            }

            return k_l[level - k_t.size()] == 1;
        }
*/

dumpQuadI(q : QuadI) -> void {
    leaves = superglue(q.leaves, \b -> if (b == 1) "1" else ".", "");
    println("Height: " + i2s(q.height));
    println("Nodes:  ");
    dumpQNodes(q, 0, 0);
	println("Level nodes:");
	iter(q.levelNodes, println);
    println("Leaves: " + leaves);
    println("Leave offsets: " + superglue(q.leavesOffset, i2s, ", "));
}

dumpQNodes(q : QuadI, level : int, node : int) -> void {
    size = pow(4, level);
    println(subrange(q.nodes, node, size));
    println(subrange(q.leavesOffset, node, size));
    if (level + 1 < q.height) {
        dumpQNodes(q, level + 1, node + pow(4, level));
    }
}

dumpQGrid(q : QuadI, size : int) -> void {
	fori(0, size - 1, \y -> {
		println(foldRange(0, size - 1, "", \acc, x -> {
			acc + if (getQuadI(q, 0, 0, 0, x, y, false)) "1" else "."
		}));
	})
}

main() {
    if (true) {
        q = build1([
                [0,1,0,0, 1,0,0,0],
                [0,0,1,1, 1,0,0,0],
                [0,0,1,0, 0,0,0,0],
                [0,0,0,0, 0,0,0,0],

                [0,0,0,0, 0,0,0,0],
                [0,0,0,0, 0,0,0,0],
                [0,0,0,0, 0,0,0,0],
                [0,0,0,0, 1,0,0,0],
            ]);
        dumpQuadI(q);
		println(getQuadI(q, 0, 0, 0, 1, 0, true));
        println("");
		dumpQGrid(q, 8);
		{}
    }

    if (false) {
		// This does not work yet
        q = build1([
                [1,1, 0,0],
                [0,1, 0,0],

                [0,0, 1,1],
                [0,0, 1,0],
            ]);
        dumpQuadI( q );

		println(getQuadI(q, 0, 0, 0, 0, 0, true));

		// dumpQGrid(q, 4);
    }

    if (false) {
        // This works
        q = build1([
                [0,0],
                [0,0],
            ]);
        dumpQuadI(q);
        dumpQGrid(q, 2);
    }
    quit(0);
}
