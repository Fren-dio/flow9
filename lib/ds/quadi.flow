import ds/bitvector;
import math/math;
import text/blueprint;

// Paper describing this here:
// https://www.dcc.uchile.cl/TR/2009/TR_DCC-20090429-005.pdf

// With implementation here: 
// https://github.com/simongog/sdsl-lite/blob/master/include/sdsl/k2_tree.hpp

// At first, we do a k=2 implementation just to get it working

QuadI(
    // How high is the tree in levels? Each level contains *4 more nits
    height : int,
    // These are really just bits. These correspond to the nodes in lexicographic order, except for the leafes
    // If the value is 0, it means that all the leaves below this node are 0.
    nodes : [int],
    // These are really just bits. We keep groups of 4 bits for each leaves which is not 0
    leaves : [int],
    // Where does the leaf for each leaf quadrant begin in terms of index into leaves?
    leavesOffset : [int],
);

// Construct a compressed QuadTree for these bools
build1(matrix : [[int]]) -> QuadI {
    n = length(matrix);
    if (n <= 2) {
        xy = \x, y -> elementAt(elementAt(matrix, y, [0]), x, 0);
        leaves = [
                xy(0,0), xy(1, 0),
                xy(0,1), xy(1, 1)
            ];
        if (leaves == [0, 0, 0, 0]) {
            QuadI(1, [0], [], [0]);
        } else {
            QuadI(1,
                [1], 
                leaves,
                [0]
            );
        }
    } else {
        height = ceil(log(i2d(length(matrix))) / log(i2d(2)));
        step = pow(2, height);
        half = step / 2;
        nw = build1(map(subrange(matrix, 0, half), \row -> subrange(row, 0, half)));
        ne = build1(map(subrange(matrix, 0, half), \row -> subrange(row, half, half)));
        sw = build1(map(subrange(matrix, half, half), \row -> subrange(row, 0, half)));
        se = build1(map(subrange(matrix, half, half), \row -> subrange(row, half, half)));
        m = mergeQuadI(mergeQuadI(mergeQuadI(nw, ne), sw), se);
        QuadI(
            m.height + 1,
            concat(
                if (m.leaves == []) [0] else [1], 
                m.nodes
            ),
            m.leaves,
            m.leavesOffset
        )
    }
}

mergeQuadI(left : QuadI, right : QuadI) -> QuadI {
    QuadI(
        left.height,
        concat(left.nodes, right.nodes),
        concat(left.leaves, right.leaves),
        concat(left.leavesOffset, map(right.leavesOffset, \o -> o  + length(left.leaves)))
    )
}

// TODO: Implement this correctly. Call with height = 0, node = 0 and leavesOffset = 0
getQuadI(q : QuadI, height : int, node : int, leavesOffset : int, x : int, y : int, debug : bool) -> bool {
	if (debug) {
		println("Looking for " + i2s(x) + "," + i2s(y) + " at node offset " + i2s(node) + " and leaf " + i2s(leavesOffset) + " at height " + i2s(height));

	}
    // If the root is empty, we know it is false
	if (height + 1 == q.height) {
		if (debug) {
			println("We are here at " + i2s(leavesOffset + x + 2 * y));
		}
		q.leaves[leavesOffset + x + 2 * y] == 1;
	} else if (q.nodes[node] == 0) false
    else {
        half = pow(2, height + 1);
		step = half * 2;
        //half = step / 2;
        north = y < half;
        west = x < half;

        offset = if (north && west) {
            0
        } else if (north && !west) {
            // NE: Check if the NW is empty or not
            if (q.nodes[node + 1] == 0) 0 else step;
        } else if (!north && west) {
            if (q.nodes[node + 1] == 0) 0 else step
            + if (q.nodes[node + 2] == 0) 0 else step;
        } else {
            if (q.nodes[node + 1] == 0) 0 else step
            + if (q.nodes[node + 2] == 0) 0 else step
            + if (q.nodes[node + 3] == 0) 0 else step;
        };

		levelOffset = pow(4, height);

		if (debug) {
			println(" with step " + i2s(step) + " and north " + b2s(north) + " and west " + b2s(west));
			println(" giving node " + i2s(node + levelOffset) + " leaf " + i2s(leavesOffset + offset));
		}

        getQuadI(q, 
			height + 1,
            node + levelOffset,
            leavesOffset + offset, 
			// We should fix these if we are east or south
			if (west) x else x - step, 
			if (north) y else y - step,
			debug
        );
    }
}

dumpQuadI(q : QuadI) -> void {
    leaves = superglue(q.leaves, \b -> if (b == 1) "1" else ".", "");
    println("Height: " + i2s(q.height));
    println("Nodes:  ");
    dumpQNodes(q, 0, 0);
    println("Leaves: " + leaves);
    println("Leave offsets: " + superglue(q.leavesOffset, i2s, ", "));
}

dumpQNodes(q : QuadI, level : int, node : int) -> void {
    size = pow(4, level);
    println(subrange(q.nodes, node, size));
    if (level + 1 < q.height) {
        dumpQNodes(q, level + 1, node + pow(4, level));
    }
}

dumpQGrid(q : QuadI, size : int) -> void {
	fori(0, size, \y -> {
		println(foldRange(0, size, "", \acc, x -> {
			acc + if (getQuadI(q, 0, 0, 0, x, y, false)) "1" else "."
		}));
	})
}

main() {
    if (true) {
        q = build1([
                [0,1,0,0, 1,0,0,0],
                [0,0,1,1, 1,0,0,0],
                [0,0,1,0, 0,0,0,0],
                [0,0,0,0, 0,0,0,0],

                [0,0,0,0, 0,0,0,0],
                [0,0,0,0, 0,0,0,0],
                [0,0,0,0, 0,0,0,0],
                [0,0,0,0, 1,0,0,0],
            ]);
        dumpQuadI(q);
		println(getQuadI(q, 0, 0, 0, 4, 0, true));
		//dumpQGrid(q, 8);
		{}
    }

    if (false) {
        dumpQuadI( 
            build1([
                [1,1,0,0],
                [0,1,0,0],
                [0,0,1,1],
                [0,0,1,0],
            ])
        );
    }

    if (false) {
        q = build1([
                [0,1],
                [0,0],
            ]);
    }
    quit(0);
}
