import ds/egraph;
import math/math;

export {
	// Extracts the cheapest enode for each class
	extractEGraph(e : EGraph<?>, costFn : (ENode<?>, [EClassCost<?>]) -> EClassCost<?>) -> Tree<int,  EClassCost<?>>;

	EClassCost(
		// The cost of this
		cost : int,
		// The node that wins
		node : ENode<?>
	);
}

ExtractorEnv(
	egraph : EGraph<?>,
	costFn : (ENode<?>, [EClassCost<?>]) -> EClassCost<?>,
	// The cheapest cost so far per class
	costs : ref Tree<int, EClassCost<?>>,
);

// https://github.com/egraphs-good/egg/blob/main/src/extract.rs
extractEGraph(e : EGraph<?>, costFn : (ENode<?>, [EClassCost<?>]) -> EClassCost<?>) -> Tree<int,  EClassCost<?>> {
	env = ExtractorEnv(e, costFn, ref makeTree());
	calcEClassCosts(env);
	^(env.costs);
}

calcEClassCosts(e : ExtractorEnv<?>) -> void {
	work = ref false;
	roots = getEClasses(e.egraph);
	iterSet(roots, \eclass : int -> {
		getEClassCost(e, eclass);
		{}
	});
	if (^work) {
		calcEClassCosts(e);
	}
}

getEClassCost(env : ExtractorEnv<?>, eclass : int) -> Maybe<EClassCost<?>> {
	mcost = lookupTree(^(env.costs), eclass);
	mcost ?? {
		Some(mcost)
	} : {
		nodes = getEClassNodes(env.egraph, eclass);
		foldSet(nodes, mcost, \acc, node -> {
			ncost = getENodeCost(env, node);
			switch (ncost) {
				None(): acc;
				Some(cost): {
					switch (acc) {
						None(): {
							env.costs := setTree(^(env.costs), eclass, cost);
							Some(cost);
						}
						Some(ec): {
							if (cost.cost < ec.cost) {
								env.costs := setTree(^(env.costs), eclass, cost);
								Some(cost);
							} else acc;
						}
					}
				}
			}
		});

	}
}

getENodeCost(env : ExtractorEnv<?>, node : ENode<?>) -> Maybe<EClassCost<?>> {
	childcosts = filtermap(node.args, \arg -> {
		getEClassCost(env, arg)
	});
	if (length(childcosts) == length(node.args)) {
		cost = env.costFn(node, map(childcosts, \cc -> cc));
		Some(cost);
	} else None();
}
