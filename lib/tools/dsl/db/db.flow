import ds/treeutils;
import tools/dsl/dsl_util;

export {
	// Prepare an empty DSL database
	makeDb() -> Db;

	//
	// Insert and extraction of DslAst values
	//

	// Insert this value in the AST
	insertDbDsl(db : Db, ast : DslAst) -> int;

	// Get this value from the AST
	lookupDbDsl(db : Db, eclass : int) -> DslAst;


	//
	// Unification API
	//

	// Unify these two eclasses
	unifyDbDsl(db : Db, eclass1 : int, eclass2 : int) -> void;

	// What eclasses are in this equivalence class?
	getDbDslEClass(db : Db, eclass : int) -> Set<int>;
}

Db(
	// 0 is unknown. 1 is false, 2 is true.
	nextId : ref int,
	// Raw values
	ints : DbValueTree<int>,
	doubles : DbValueTree<double>,
	strings : DbValueTree< string>,
	arrays : DbValueTree<[int]>,
	// AST nodes - can probably be specialized for specific types down the line
	nodes : DbValueTree<[int]>,

	// Here we track unifications of eclasses
	eclasses : EClassTree,
);

makeDb() -> Db {
	Db(
		ref 3,
		DbValueTree(ref makeTree(), ref makeTree()),
		DbValueTree(ref makeTree(), ref makeTree()),
		DbValueTree(ref makeTree(), ref makeTree()),
		DbValueTree(ref makeTree(), ref makeTree()),
		DbValueTree(ref makeTree(), ref makeTree()),
		EClassTree(ref makeTree(), ref makeTree()),
	);
}

insertDbDsl(db : Db, ast : DslAst) -> int {
	switch (ast) {
		DslBool(value): if (value) 2 else 1;
		DslInt(value): insertDbValueTree(db.nextId, db.ints, value);
		DslDouble(value): insertDbValueTree(db.nextId, db.doubles, value);
		DslString(value): insertDbValueTree(db.nextId, db.strings, value);
		DslList(value): {
			a : [DslAst] = list2array(value);
			ids = map(a, \v -> insertDbDsl(db, v));
			insertDbValueTree(db.nextId, db.arrays, ids);
		}
		DslNode(name, args, pos): {
			sid = insertDbDsl(db, DslString(name));
			argids = map(args, \a -> insertDbDsl(db, a));
			posid = insertDbDsl(db, DslInt(pos));
			ids = concat3([sid], argids, [posid]);
			insertDbValueTree(db.nextId, db.nodes, ids);
		}
	}
}

// A dual lookup data structure
DbValueTree(fromIdx : ref Tree<int, ?>, toIdx : ref Tree<?, int>);

insertDbValueTree(nextId : ref int, tree : DbValueTree<?>, value : ?) -> int {
	mid = lookupTree(^(tree.toIdx), value);
	mid ?? mid : {
		id = ^nextId;
		tree.fromIdx := setTree(^(tree.fromIdx), id, value);
		tree.toIdx := setTree(^(tree.toIdx), value, id);
		nextId := id + 1;
		id;
	}
}

lookupDbDsl(db : Db, eclass : int) -> DslAst {
	if (eclass == 1) DslBool(false)
	else if (eclass == 2) DslBool(true)
	else {
		rec = \ii -> lookupDbDsl(db, ii);
		if (containsKeyTree(^(db.arrays.fromIdx), eclass)) {
			ids = getTreeArrayValue(^(db.arrays.fromIdx), eclass);
			DslList(fold(ids, makeList(), \acc, id -> Cons(rec(id), acc)))
		} else if (containsKeyTree(^(db.nodes.fromIdx), eclass)) {
			ids = getTreeArrayValue(^(db.nodes.fromIdx), eclass);
			vals = map(ids, rec);
			DslNode(getDslString(vals[0]), subrange(vals, 1, length(vals) - 2), getDslInt(vals[1]));
		} else if (containsKeyTree(^(db.ints.fromIdx), eclass)) {
			DslInt(lookupTreeDef(^(db.ints.fromIdx), eclass, 0))
		} else if (containsKeyTree(^(db.doubles.fromIdx), eclass)) {
			DslDouble(lookupTreeDef(^(db.doubles.fromIdx), eclass, 0.0))
		} else if (containsKeyTree(^(db.strings.fromIdx), eclass)) {
			DslString(lookupTreeDef(^(db.strings.fromIdx), eclass, ""))
		} else {
			DslString("ERROR: Unknown eclass " + toString(eclass))
		}
	}
}

EClassTree(
	// Lookup from an eclass to the root
	roots : ref Tree<int, int>,
	// Lookup from an eclass to the members of this set
	eclass : ref Tree<int, Set<int>>,
);

unifyDbDsl(db : Db, eclass1 : int, eclass2 : int) -> void {
	root1 = lookupTreeDef(^(db.eclasses.roots), eclass1, eclass1);
	root2 = lookupTreeDef(^(db.eclasses.roots), eclass2, eclass2);

	members1 = lookupMultimap(^(db.eclasses.eclass), root1);
	members2 = lookupMultimap(^(db.eclasses.eclass), root2);

	root = 
		if (root1 < root2) {
			db.eclasses.roots := setTree(^(db.eclasses.roots), eclass2, root1);
			db.eclasses.eclass := removeFromTree(^(db.eclasses.eclass), eclass2);
			root1;
		} else {
			db.eclasses.roots := setTree(^(db.eclasses.roots), eclass1, root2);
			db.eclasses.eclass := removeFromTree(^(db.eclasses.eclass), eclass1);
			root2;
		};

	mmembers1 = mergeSets(members1, members2);
	mmembers2 = insertSet(mmembers1, root1);
	mmembers3 = insertSet(mmembers2, root2);
	db.eclasses.eclass := setTree(^(db.eclasses.eclass), root, mmembers3);
}

getDbDslEClass(db : Db, eclass : int) -> Set<int> {
	mroot = lookupTree(^(db.eclasses.roots), eclass);
	mroot ?? {
		lookupMultimap(^(db.eclasses.eclass), mroot)
	} : {
		makeSet1(eclass)
	}
}
