import ds/treeutils;
import tools/dsl/dsl_util;

export {
	// Prepare an empty DSL database
	makeDb() -> Db;

	//
	// Insert and extraction of DslAst values
	//

	// Insert this value in the AST. Figures out what table to use automatically
	// bool, ints, doubles, string are handled in a special table
	// arrays are placed in a table called ""
	// nodes are placed in a table with the name of the node.
	// If the value already exists, we get out the existing id of it instead.
	insertDbDsl(db : Db, ast : DslAst) -> int;

	// Get this value from the AST. Not efficient, but at least it works
	lookupDbDsl(db : Db, eclass : int) -> DslAst;
}

Db(
	// 0 is unknown. 1 is false, 2 is true.
	nextId : ref int,
	// Raw values
	ints : DbTable<int>,
	doubles : DbTable<double>,
	strings : DbTable<string>,
	// Here we have each table for each relation
	// Arrays are stored under the "" name
	tables : ref Tree<string, DbTable<[int]>>,
);

makeDb() -> Db {
	Db(
		ref 3,
		makeDbTable(),
		makeDbTable(),
		makeDbTable(),
		ref makeTree(),
	);
}

insertDbDsl(db : Db, ast : DslAst) -> int {
	switch (ast) {
		DslBool(value): if (value) 2 else 1;
		DslInt(value): insertDbTable(db.nextId, db.ints, value);
		DslDouble(value): insertDbTable(db.nextId, db.doubles, value);
		DslString(value): insertDbTable(db.nextId, db.strings, value);
		DslList(value): {
			a : [DslAst] = list2array(value);
			ids = map(a, \v -> insertDbDsl(db, v));
			insertDbNamedTable(db, "", ids);
		}
		DslNode(name, args, pos): {
			argids = map(args, \a -> insertDbDsl(db, a));
			posid = insertDbDsl(db, DslInt(pos));
			ids = concat(argids, [posid]);
			insertDbNamedTable(db, name, ids);
		}
	}
}

insertDbNamedTable(db : Db, table : string, value : [int]) -> int {
	mtable = lookupTree(^(db.tables), table);
	mtable ?? {
		insertDbTable(db.nextId, mtable, value);
	} : {
		tree = makeDbTable();
		nvalue = insertDbTable(db.nextId, tree, value);
		db.tables := setTree(^(db.tables), table, tree);
		nvalue
	}
}

// Extract the DSL value for this class
lookupDbDsl(db : Db, eclass : int) -> DslAst {
	if (eclass == 1) DslBool(false)
	else if (eclass == 2) DslBool(true)
	else {
		if (containsKeyTree(^(db.ints.fromIdx), eclass)) {
			DslInt(lookupTreeDef(^(db.ints.fromIdx), eclass, 0))
		} else if (containsKeyTree(^(db.doubles.fromIdx), eclass)) {
			DslDouble(lookupTreeDef(^(db.doubles.fromIdx), eclass, 0.0))
		} else if (containsKeyTree(^(db.strings.fromIdx), eclass)) {
			DslString(lookupTreeDef(^(db.strings.fromIdx), eclass, ""))
		} else {
			mvalue = foldTree(^(db.tables), None(), \name, table : DbTable, acc -> {
				switch (acc) {
					None(): {
						rec = \ii -> lookupDbDsl(db, ii);
						if (containsKeyTree(^(table.fromIdx), eclass)) {
							ids = getTreeArrayValue(^(table.fromIdx), eclass);
							if (name == "") {
								Some(DslList(fold(ids, makeList(), \acc2, id -> Cons(rec(id), acc2))))
							} else {
								vals = map(ids, rec);
								Some(DslNode(name, subrange(vals, 0, length(vals) - 1), getDslInt(vals[length(vals) - 1])));
							}
						} else acc;
					}
					Some(__): acc;
				}
			});
			switch (mvalue) {
				None(): DslString("ERROR: Unknown eclass " + toString(eclass));
				Some(l): l;
			}
		}
	}
}

// A dual lookup data structure
DbTable(
	fromIdx : ref Tree<int, ?>, 
	toIdx : ref Tree<?, int>,
);

makeDbTable() -> DbTable<?> {
	DbTable(ref makeTree(), ref makeTree());
}

// Inserts this value in the database, unless it already is there
insertDbTable(nextId : ref int, tree : DbTable<?>, value : ?) -> int {
	mid = lookupTree(^(tree.toIdx), value);
	mid ?? mid : {
		// OK, not found, so insert it with a new id
		id = ^nextId;
		tree.fromIdx := setTree(^(tree.fromIdx), id, value);
		tree.toIdx := setTree(^(tree.toIdx), value, id);
		nextId := id + 1;
		id;
	}
}

