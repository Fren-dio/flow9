import tools/gringo/pflow/parse;
import tools/gringo/pflow/interpreter;
import tools/gringo/pflow/typechecker;
import tools/gringo/pflow/prettyprint;

main() {
	code = "#include tools/gringo/pflow/tests/fact.flow";

	e : PExp = parsePFlow(code);

	tenv = makeTypeEnv();
	t0 : TExp = convertPExp2TExp(tenv, e);
	t1 : TType = typecheckTExp(tenv, t0);

	println("Tyvar bindings:");
	traverseInOrder(^(tenv.tyvars), \tv, type -> {
		root = unionFind(tenv.unionFind, tv);
		println(i2s(tv) + ": " + prettyTType(tenv, type) + " has root " +i2s(root));
	});

	println("Equivalence class");
	generate(0, ^(tenv.unique), \tv -> {
		root = unionFind(tenv.unionFind, tv);
		println("Root of " + i2s(tv) + " is " + i2s(root));
	});

	rt : TExp = resolveTExp(tenv, t0);
	println(prettyTExp(tenv, rt));
/*
	value = interpretPExp(makeTree(), e);

	println(value);*/
	quit(0);
}
