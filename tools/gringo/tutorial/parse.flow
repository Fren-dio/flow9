import tools/gringo/tutorial/exp;
import text/gringo/gringo_interpreter;
import text/deserialize_string;
export {
	parseExpWithGringo(program : string, onError : (string) -> void) -> Exp;
}

parseExpWithGringo(program : string, onError : (string) -> void) -> Exp {
	gterm = prepareGringoParser("#include tools/gringo/tutorial/exp.gringo", onError);
	if (gterm != GEpsilon()) {
		// OK, parse the program
		gringoInterpretedParse(program, expTypeAction(onError), gterm, Int(0), onError);
	} else {
		onError("Could not understand grammar");
		Int(0);
	}
}

// This defines the semantic actions used in the grammar
expTypeAction(onError : (string) -> void) -> GringoAction<List<Exp>> {
	un = \op -> Pair(op, \l -> Call(op, [l]));
	bin = \op -> Pair(op, \l, r -> Call(op, [l, r]));
	tri = \op -> Pair(op, \l, m, r -> Call(op, [l, m, r]));
	gringoTypedAction(
		// Make a string
		\s : string -> String(s),
		// Extract a string from a value (typically a string)
		\e : Exp -> switch (e) {
			String(s): s;
			default: { onError("Expected string"); ""; }
		},
		// Construct the basic value
		\b -> Int(b2i(b)), // We do not have bools, so use ints
		\i -> Int(s2i(i)),
		\d -> Int(s2i(d)), // We do not have doubles, so just use ints
		// Construct an empty array
		\ -> Array([]),
		// Append an element to an array
		\h, t -> {
			switch (t) {
				Array(es): Array(arrayPush(es, h));
				default: t;
			}
		},
		// A Tree<string, (Exp) -> Exp> of unary operator constructors
		pairs2tree([
			un("negate"),
			Pair("unescape", \e -> {
				switch (e) {
					String(t): String(deserializeString(t).first);
					default: e;
				}
			})
		]),
		// A Tree<string, (Exp, Exp) -> Exp> of binary operator constructors
		pairs2tree([
			bin("||"), bin("&&"),
			bin("=="), bin("!="),
			bin("<="), bin("<"), bin(">"), bin(">="),
			bin("+"), bin("-"), 
			bin("*"), bin("/"), bin("%"), 
			bin("index"), bin("dot"),
			bin("if"), 
		]),
		// A Tree<string, (Exp, Exp, Exp) -> Exp> of ternary operator constructors
		pairs2tree([
			tri("ifelse")
		])
	);
}
