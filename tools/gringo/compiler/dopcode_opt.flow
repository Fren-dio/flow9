import tools/gringo/compiler/dopcode;
import runtime;

export {
	optimizeDOpCode(d : DOpCode) -> DOpCode;
}

optimizeDOpCode(d : DOpCode) -> DOpCode {
	switch (d) {
		DFunction(name, code, body): {
			DFunction(name, optimizeDOpCode(code), optimizeDOpCode(body));
		}
		DTrue(): d;
		DFalse(): d;
		DString(s): d;
		DIf(cond, then, else_): {
			// Split any prefix in the condition out in front
			oc = optimizeDOpCode(cond);
			split = splitDSequence(oc);

			ot = optimizeDOpCode(then);
			oe = optimizeDOpCode(else_);
			seq = arrayPush(split.first,
					if (isDOpCodeTrue(split.second)) {
						ot
					} else {
						DIf(split.second, ot, oe)
					}
				);
			if (length(seq) == 1) seq[0]
			else DSequence(seq)
		}
		DSequence(exps): {
			seq = concatA(filtermapi(exps, \i, e -> {
				co = optimizeDOpCode(e);
				islast = i == length(exps) - 1;
				if (!islast && (co == DSequence([]) || co == DTrue() || co == DFalse())) {
					None();
				} else {
					Some(switch (co) {
						DSequence(ns): ns;
						default: [co];
					})
				}
			}));
			nseq = optimizeDMatchString(seq, 0, []);
			DSequence(nseq);
		}
		DPushCheckpoint(): d;
		DDiscardCheckpoint(): d;
		DRestoreCheckpoint(): d;
		DParseStar(term): DParseStar(optimizeDOpCode(term));
		DAddError(error): d;
		DCaptureI(): d;
		DMatched(): d;
		DPosition(): d;
		DAddVerbatim(e): DAddVerbatim(optimizeDOpCode(e));
		DAddMatched(e): DAddMatched(optimizeDOpCode(e));
		DMatchString(text): d;
		DMatchRange(lower, upper): d;
		DCall(id): d;
	}
}


// If this is a sequence, split into the head and the tail
splitDSequence(f : DOpCode) -> Pair<[DOpCode], DOpCode> {
	switch (f) {
		DSequence(exprs): {
			n = length(exprs);
			if (n == 0) Pair([], f)
			else Pair(subrange(exprs, 0, n - 1), exprs[n-1]);
		}
		default: Pair([], f);
	}
}


isDOpCodeTrue(d : DOpCode) -> bool {
	switch (d) {
		DTrue(): true;
		DSequence(ops): {
			if (ops == []) false
			else isDOpCodeTrue(lastElement(ops, DTrue()))
		}
		default: false;
	}
}

/*
	DSequence([
		...,
		DPushCheckpoint(),
		DIf(
			DMatchString(<string>) or DMatchRange,
			<exp>,
			DRestoreCheckpoint()
		),
		...
	])

	can become

		DIf(
			DMatchString(<string>) or DMatchRange,
			<exp>,
			DFalse()
		),

in code:

	pushDCheckpoint(acc);
	if (matchString(acc, "\\uFEFF")) {
		...
		...
	} else {
		restoreDCheckpoint(acc)
	};

*/
optimizeDMatchString(seq : [DOpCode], i : int, acc : [DOpCode]) -> [DOpCode] {
	rest = \ -> {
		optimizeDMatchString(seq, i + 1, arrayPush(acc, seq[i]));
	}
	// TODO: This is not correct yet, since in the body of "then", there
	// can be some discard and restore points, which are harder to handle.
	if (false && i + 1 < length(seq)) {
		if (seq[i] == DPushCheckpoint()) {
			// OK, see if we have an DIf
			after = seq[i + 1];
			switch (after) {
				DIf(cond, then, else_): {
					if (else_ == DRestoreCheckpoint()) {
						match = switch (cond) {
							DMatchString(__): true;
							DMatchRange(__, __): true;
							default: false;
						}
						if (match) {
							// OK, we have something of the given pattern.
							/*
							DIf(
								DMatchString(<string>) or DMatchRange,
								<exp>,
								DFalse()
							),
							*/
							con = DIf(
								cond,
								then,
								DFalse()
							);
							optimizeDMatchString(seq, i + 2, arrayPush(acc, con));
						} else {
							rest();
						}
					} else rest();
				}
				default: rest();
			}
		} else {
			rest();
		}
	} else {
		if (i < length(seq)) {
			rest();
		} else acc
	}
}
