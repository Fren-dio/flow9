import tools/dsl/dsl_ast_typed;
import tools/dsl/dsl_pretty;
import tools/dsl/dsl_util;
import ds/tuples;
import ds/array;
import ds/tree;
import ds/union_find_map;
import algorithms;

export {
	// Unification based type inference.
	// You decide what types exist in your language by implementing
	// typeFn. Also mergeTypes defines how types can be merged.

	// At the end, the types are annotated as an extra child on the DslNodes.

	// For normal types, use DslString("i32"). 
	// For tuples, DslList() work as a tuple type, and for other composite types 
	// DlsNode(name, [typars], 0) works as well

	dslTypeInfer(
		d : DslAst,
		// Merge two types
		mergeTypes : (DslTypeAcc, DslAst, DslAst) -> DslAst,
		// Give the type of this node, provided the children have these types.
		// If you do not know the type yet, return DslInt(0), and it will be handled as a tyvar.
		typeFn : (DslTypeAcc, node : DslAst, getChildType : (int) -> DslAst) -> DslAst
	) -> DslAst;

	// For composite types, you can construct a tyvar here
	makeDslTypeVar(acc : DslTypeAcc) -> DslAst;
}

DslTypeAcc(
	tyvar : ref int,
	env : ref Tree<string, DslAst>,
	tyvars : UnionFindMap<DslAst>,
	// Provided by user to extract the type of a given node
	typeFn : (DslTypeAcc, DslAst, getChildType : (int) -> DslAst) -> DslAst,
	// Used by the user to merge classes
	unifyTypes : (DslTypeAcc, DslAst, DslAst) -> void,
	// Error reporting
	onError : (DslAst, error : string) -> void,
	// For debugging
	indent : ref string,
	// Debugging?
	debugging : bool
);

dummyDslNode = DslNode("", [], 0);

dslTypeInfer(d : DslAst, 
		// Merge two types
		mergeTypes : (DslTypeAcc, DslAst, DslAst) -> DslAst,
		typeFn : (DslTypeAcc, DslAst, getChildType : (int) -> DslAst) -> DslAst) -> DslAst {

	// Do a dance to hook up the merge function
	merger = ref \left : DslAst, right : DslAst -> left;
	acc = DslTypeAcc(ref 0, 
		ref makeTree(), 
		makeUnionFindMap(dummyDslNode, \left, right -> (^merger)(left, right)),
		typeFn, unifyDslTypes,
		\n, error -> {
			println(error);
		}, ref "",
		false // Debugging
	);
	merger := \left, right -> {
		if (left == dummyDslNode) right
		else if (right == dummyDslNode) left
		else mergeTypes(acc, left, right);
	}

	t : DslAstTyped = dsl2typed(acc, d);

	type = dslTypeCheck(acc, t);

	resolveDslTypes(acc, t);
}

// Decorate the AST with tyvars
dsl2typed(env : DslTypeAcc, d : DslAst) -> DslAstTyped {
	switch (d) {
		DslBool(value): d;
		DslInt(value): d;
		DslDouble(value): d;
		DslString(value): d;
		DslList(l): {
			DslListTyped(mapList(l, \e -> dsl2typed(env, e)), nextDsltyvar(env));
		}
		DslNode(name, args, pos): {
			DslNodeTyped(name, map(args, \e -> dsl2typed(env, e)), pos, nextDsltyvar(env));
		}
	}
}

typed2dsl(d : DslAstTyped) -> DslAst {
	switch (d) {
		DslBool(value): d;
		DslInt(value): d;
		DslDouble(value): d;
		DslString(value): d;
		DslListTyped(value, eclass): DslList(mapList(value, typed2dsl));
		DslNodeTyped(name, args, pos, eclass): DslNode(name, map(args, typed2dsl), pos);
	}
}

dslTypeCheck(acc : DslTypeAcc, node : DslAstTyped) -> DslAst {
	indent = ^(acc.indent);
	if (acc.debugging) {
		println(indent + "Type checking " + summarizeDsl(typed2dsl(node)));
		acc.indent := indent + "  ";
	}
	res = switch (node) {
		DslBool(b): acc.typeFn(acc, node, \__ -> node);
		DslInt(b): acc.typeFn(acc, node, \__ -> node);
		DslDouble(b): acc.typeFn(acc, node, \__ -> node);
		DslString(b): acc.typeFn(acc, node, \__ -> node);
		DslListTyped(l, tyvar): {
			children = list2array(l);
			childType = \c -> dslTypeCheck(acc, children[c]);
			res = acc.typeFn(acc, typed2dsl(node), childType);
			if (res == DslInt(0)) {
				// OK, it is not known yet
				DslInt(tyvar);
			} else {
				setDslTypeVar(acc, tyvar, res);
			}
		}
		DslNodeTyped(name, args, pos, tyvar): {
			childType = \c -> dslTypeCheck(acc, args[c]);
			res = acc.typeFn(acc, typed2dsl(node), childType);
			if (res == DslInt(0)) {
				// OK, it is not known yet
				DslInt(tyvar);
			} else {
				setDslTypeVar(acc, tyvar, res);
			}
		}
	};
	if (acc.debugging) {
		println(indent + "Type checked " + summarizeDsl(typed2dsl(node)) + ": " + prettyDsl(res));
		acc.indent := indent;
	}
	res;
}

summarizeDsl(d : DslAst) -> string {
	switch (d) {
		DslBool(value): b2s(value);
		DslInt(value): i2s(value);
		DslDouble(value): d2s(value);
		DslString(value): toString(value);
		DslList(value): {
			arr = reverseA(list2array(value));
			"[" + superglue(arr, summarizeDsl, "::") + "]";
		}
		DslNode(name, args, pos): {
			children = map(args, summarizeDsl);
			name + "(" + strGlue(children, ", ") + ")"
		}
	}
}

makeDslTypeVar(acc : DslTypeAcc) -> DslAst {
	DslInt(nextDsltyvar(acc))
}

nextDsltyvar(env : DslTypeAcc) -> int {
	id = ^(env.tyvar);
	env.tyvar := id + 1;
	id;
}

setDslTypeVar(acc : DslTypeAcc, tyvar : int, type : DslAst) -> DslAst {
	etype = getUnionMapValue(acc.tyvars, tyvar);
	res = if (etype == dummyDslNode || etype == type) {
		type
	} else {
		acc.onError(type, "Not supposed to happen: Updating " + i2s(tyvar));
		type
		// acc.mergeTypes(acc, etype, type)
	}
	setUnionMapValue(acc.tyvars, tyvar, res);
	res;
}

unifyDslTypes(acc : DslTypeAcc, left : DslAst, right : DslAst) -> void {
	if (acc.debugging) {
		indent = ^(acc.indent);
		println(indent + "Unifying " + prettyDsl(left) + " and " + prettyDsl(right));
	}
	if (left == right) {}
	else {
		error = \ -> {
			acc.onError(left, "TYPE ERROR: " + prettyDsl(left) + " is not compatible with " + prettyDsl(right));
		};
		checkright = \ -> {
			switch (right) {
				DslInt(rvalue): {
					// OK, we have a tyvar
					setDslTypeVar(acc, rvalue, left);
					{}
				}
				default: error();
			}
		}
		switch (left) {
			DslBool(value): error();
			DslInt(lvalue): {
				// This is a tyvar
				switch (right) {
					DslInt(rvalue): {
						// OK, tyvar vs tyvar
						unionUnionMap(acc.tyvars, lvalue, rvalue);
						{}
					}
					default: {
						setDslTypeVar(acc, lvalue, right);
						{}
					}
				}
			}
			DslDouble(value): error();
			DslString(value): {
				if (getDslString(right) != value) {
					checkright();
				}
			}
			DslList(value): {
				llist = list2array(getDslList(left));
				rlist = list2array(getDslList(right));
				if (length(llist) != length(rlist)) {
					checkright();
				} else {
					iteri(llist, \i, ll -> {
						unifyDslTypes(acc, ll, rlist[i])
					})
				}
			}
			DslNode(lname, largs, __): {
				rnode = getDslNode(right);
				if (lname != rnode.name || length(largs) != length(rnode.args)) {
					checkright();
				} else {
					iteri(largs, \i, larg -> {
						unifyDslTypes(acc, larg, rnode.args[i])
					})
				}
			}
		}
	}
}

resolveDslTypes(acc : DslTypeAcc, node : DslAstTyped) -> DslAst {
	switch (node) {
		DslBool(value): node;
		DslInt(value): node;
		DslDouble(value): node;
		DslString(value): node;
		DslListTyped(value, eclass): {
			type = getUnionMapValue(acc.tyvars, eclass);
			switch (type) {
				DslList(__): {}
				default: acc.onError(typed2dsl(node), "List type expected here, got " + toString(type));
			}
			DslList(mapList(value, \v -> {
				resolveDslTypes(acc, v)
			}))
		}
		DslNodeTyped(name, args, pos, eclass): {
			type = getUnionMapValue(acc.tyvars, eclass);
			DslNode(name, 
				// We add the type as the last node
				arrayPush(
					map(args, \a -> {
						resolveDslTypes(acc, a)
					}), 
					type
				),
				pos
			)
		}
	}
}
