import tools/dsl/dsl_ast_typed;
import tools/dsl/dsl_pretty;
import tools/dsl/dsl_util;
import ds/tuples;
import ds/array;
import ds/tree;
import ds/union_find_map;
import algorithms;

export {
	// Unification based type inference
	dslTypeInfer(
		d : DslAst,
		// Merge two types
		mergeTypes : (DslTypeAcc, DslAst, DslAst) -> DslAst,
		// Give the type of this node, provided the children have these types
		typeFn : (DslTypeAcc, node : DslAst, getChildTypes : () -> [DslAst]) -> DslAst
	) -> DslAst;
}

DslTypeAcc(
	tyvar : ref int,
	env : ref Tree<string, DslAst>,
	tyvars : UnionFindMap<DslAst>,
	// Used when two types need to be merged
	mergeTypes : (DslTypeAcc, DslAst, DslAst) -> DslAst,
	// Provided by user to extract the type of a given node
	typeFn : (DslTypeAcc, DslAst, getChildTypes : () -> [DslAst]) -> DslAst,
	// Used by the user to merge classes
	unifyTypes : (DslTypeAcc, DslAst, DslAst) -> void,
);

dummyDslNode = DslNode("", [], 0);

dslTypeInfer(d : DslAst, 
		// Merge two types
		mergeTypes : (DslTypeAcc, DslAst, DslAst) -> DslAst,
		typeFn : (DslTypeAcc, DslAst, getChildTypes : () -> [DslAst]) -> DslAst) -> DslAst {

	// Do a dance to hook up the merge function
	merger = ref \left : DslAst, right : DslAst -> left;
	acc = DslTypeAcc(ref 0, 
		ref makeTree(), 
		makeUnionFindMap(dummyDslNode, \left, right -> (^merger)(left, right)),
		mergeTypes, typeFn, unifyDslTypes
	);
	merger := \left, right -> mergeTypes(acc, left, right);

	t : DslAstTyped = dsl2typed(acc, d);

	type = dslTypeCheck(acc, t);

	// TODO: We should resovle the types into the nodes in the AST
	d;
}

// Decorate the AST with tyvars
dsl2typed(env : DslTypeAcc, d : DslAst) -> DslAstTyped {
	switch (d) {
		DslBool(value): d;
		DslInt(value): d;
		DslDouble(value): d;
		DslString(value): d;
		DslList(l): {
			DslListTyped(mapList(l, \e -> dsl2typed(env, e)), nextDsltyvar(env));
		}
		DslNode(name, args, pos): {
			DslNodeTyped(name, map(args, \e -> dsl2typed(env, e)), pos, nextDsltyvar(env));
		}
	}
}

typed2dsl(d : DslAstTyped) -> DslAst {
	switch (d) {
		DslBool(value): d;
		DslInt(value): d;
		DslDouble(value): d;
		DslString(value): d;
		DslListTyped(value, eclass): DslList(mapList(value, typed2dsl));
		DslNodeTyped(name, args, pos, eclass): DslNode(name, map(args, typed2dsl), pos);
	}
}

dslTypeCheck(acc : DslTypeAcc, node : DslAstTyped) -> DslAst {
	switch (node) {
		DslBool(b): acc.typeFn(acc, node, \ -> []); // booltype()
		DslInt(b): acc.typeFn(acc, node, \ -> []); // inttype()
		DslDouble(b): acc.typeFn(acc, node, \ -> []); // doubletype()
		DslString(b): acc.typeFn(acc, node, \ -> []); // stringtype()
		DslListTyped(l, tyvar): {
			childTypes = \ -> map(list2array(l), \e -> {
				dslTypeCheck(acc, e)
			});
			res = acc.typeFn(acc, typed2dsl(node), childTypes);
			setDslTypeVar(acc, tyvar, res);
		}
		DslNodeTyped(name, args, pos, tyvar): {
			childTypes = \ -> map(args, \a -> {
				dslTypeCheck(acc, a);
			});
			res = acc.typeFn(acc, typed2dsl(node), childTypes);
			setDslTypeVar(acc, tyvar, res);
		}
	}
}

nextDsltyvar(env : DslTypeAcc) -> int {
	id = ^(env.tyvar);
	env.tyvar := id + 1;
	id;
}

setDslTypeVar(acc : DslTypeAcc, tyvar : int, type : DslAst) -> DslAst {
	etype = getUnionMapValue(acc.tyvars, tyvar);
	res = if (etype == dummyDslNode) {
		type
	} else {
		acc.mergeTypes(acc, etype, type)
	}
	setUnionMapValue(acc.tyvars, tyvar, res);
	res;
}

unifyDslTypes(acc : DslTypeAcc, left : DslAst, right : DslAst) -> void {
	if (left == right) {}
	else {
		error = \ -> {
			println("TYPE ERROR: " + prettyDsl(left) + " is not compatible with " + prettyDsl(right));
		};
		lnode = getDslNode(left);
		rnode = getDslNode(right);
		if (lnode.name != rnode.name || length(lnode.args) != length(rnode.args)) {
			error();
		} else {
			iteri(lnode.args, \i, larg -> {
				unifyDslTypes(acc, larg, rnode.args[i])
			})
		}
	}
}
