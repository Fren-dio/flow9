import tools/gringo/gringo_embed;
import tools/gringo/json_actions;
import ds/egraph_matching;

export {
	// Prepares a grammar for a language "name"
	defineGrammar(name : string, grammar : string) -> DslGrammar;

	// Parses a set of EGraph rewriting rules in the given language grammar
	parseRules(grammar : DslGrammar, rules : string) -> DslRules;

	// Parses a program in the given language
	parseProgram(grammar : DslGrammar, program : string) -> Json;

	// Builds the cost structure for graph rewriting
	rewriteCosts(costs : string) -> DslCosts;

	// Prepares a compiler from the given language to the target language
	makeCompiler(grammar : DslGrammar, target : string, blueprints : string) -> DslCompiler;
}

DslGrammar(
	language : string,
	term : GTerm
);

DslRules(
	replacements : [EReplacement<Json>]
);

DslCosts(
	costs : Tree<Json, int>
);

DslCompiler(
	language : DslGrammar,
	target : string,
	blueprints : [EReplacement<string>]
);

defineGrammar(name : string, grammar : string) -> DslGrammar {
	DslGrammar(name, parseAndCheckGringoGrammar(name, grammar));
}

parseRules(grammar : DslGrammar, rules : string) -> DslRules {
	// TODO: Build a new grammar where we have
	// grammar on each side of the rules
	// and <exp> => <exp> as the result
	DslRules(
		[]
	);
}

parseProgram(grammar : DslGrammar, program : string) -> Json {
	genv = doGringoParse(grammar.term, jsonAction, makeList(), program, false, false);
	getJsonGringo(genv.output);
}

rewriteCosts(costs : string) -> DslCosts {
	DslCosts(makeTree());
}

makeCompiler(grammar : DslGrammar, target : string, blueprints : string) -> DslCompiler {
	DslCompiler(
		grammar,
		target,
		[],
	);
}
