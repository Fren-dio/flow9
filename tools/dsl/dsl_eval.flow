import tools/dsl/dsl_pretty;
import tools/dsl/dsl_util;

export {
	makeDslEnv() -> DslEnv;
	evaluateDsl(env : DslEnv, p : DslAst) -> DslAst;

	DslEnv(
		locals : Tree<string, DslAst>, 
		natives : Tree<string, ([DslAst]) -> DslAst>
	);
}

makeDslEnv() -> DslEnv {
	DslEnv(makeTree(), makeTree());
}

evaluateDsl(env : DslEnv, p : DslAst) -> DslAst {
	switch (p) {
		DslNode(name, args, pos): {
			if (name == "int" || name == "double" || name == "string") {
				args[0]
			} else if (name == "ifelse") {
				cond = evaluateDsl(env, args[0]);
				evaluateDsl(env, if (getDslBool(cond)) args[1] else args[2]);
			} else if (name == "let") {
				let = getDslString(args[0]);
				val = evaluateDsl(env, args[1]);
				if (let == "") {
					// Check if we are a dyn
					letnode = getDslNode(args[0]);
					if (letnode.name == "dyn") {
						// TODO: Make a tmp variable name for this
						// and replace all occurences in the body with 
						// this new var, as well as mark this new var
						// as dynamic, and then evaluate the body
						nbody = evaluateDsl(env, args[2]);
						DslNode("let", [letnode.args[0], val, nbody], pos);
					} else {
						error = "Unsupported let-binding " + prettyDsl(args[0]);
						println(error);
						DslString(error);
					}
				} else {
					nenv = DslEnv(env with locals = setTree(env.locals, let, val));
					evaluateDsl(nenv, args[2]);
				}
			} else if (name == "var") {
				mvar = lookupTree(env.locals, getDslString(args[0]));
				mvar ?? mvar : {
					// TODO: Check that p is dynamic, otherwise complain
					p;
				}
			} else if (name == "lambda") {
				instantiateDslLocals(env, p);
			} else if (name == "call") {
				fn = evaluateDsl(env, args[0]);
				// println("Call to " + prettyDsl(fn));
				lambda : DslNode = getDslNode(fn);
				if (lambda.name == "lambda") {
					eargs : List<DslAst> = getDslList(evaluateDsl(env, args[1]));
					nargs = list2array(getDslList(lambda.args[0]));
					body = lambda.args[1];
					nenv = DslEnv(env with locals = foldi(list2array(eargs), env.locals, \i, acc, arg -> {
						// println("Setting par " + getDslString(nargs[i]) + " to " + prettyDsl(arg));
						setTree(acc, getDslString(nargs[i]), arg)
					}));
					evaluateDsl(nenv, body);
				} else if (lambda.name == "var") {
					// Normal functions
					vname = getDslString(lambda.args[0]);
					eargs : List<DslAst> = getDslList(evaluateDsl(env, args[1]));
					envNative = lookupTree(env.natives, vname);
					switch (envNative) {
						None(): {
							mnative = getDslNative(vname);
							mnative ?? {
								mnative.fn(list2array(eargs));
							} : {
								// Unknown, so error out
								node = DslNode(vname, list2array(eargs), pos);
								println("Unknown var '" + vname + "'");
								DslString("Unknown var " + vname);
							}
						}
						Some(nativeFn): nativeFn(list2array(eargs));
					}
				} else {
					println("ERROR: Can not call " + prettyDsl(fn));
					p;
				}
			} else if (name == "and") {
				// Shortcircut
				left = evaluateDsl(env, args[0]);
				if (getDslBool(left)) {
					evaluateDsl(env, args[1]);
				} else left;
			} else if (name == "or") {
				// Shortcircut
				left = evaluateDsl(env, args[0]);
				if (getDslBool(left)) {
					left
				} else evaluateDsl(env, args[1]);
			} else if (name == "quote") {
				unquoteDsl(env, args[0])
			} else {
				// Normal functions
				eargs = map(args, \a -> {
					evaluateDsl(env, a);
				});
				mnative = getDslNative(name);
				mnative ?? {
					mnative.fn(eargs)
				} : {
					if (name == "bind") {
						// OK, we just evaluate the child an extra time
						evaluateDsl(env, eargs[0]);
					} else {
						println("UNKNOWN name " + name);
						DslNode(name, eargs, pos);
					}
				}
			}
		}
		DslList(value): {
			vals = map(list2array(value), \v -> evaluateDsl(env, v));
			DslList(fold(vals, makeList(), \acc, val -> Cons(val, acc)));
		}
		DslBool(value): p;
		DslInt(value): p;
		DslDouble(value): p;
		DslString(value): p;
	}
}

// For handling lambdas
instantiateDslLocals(env : DslEnv, p : DslAst) -> DslAst {
	var = \id : string -> {
		DslNode("var", [DslString(id)], 0)
	};
	switch (p) {
		DslNode(name, args, pos): {
			if (name == "let") {
				let = getDslString(args[0]);
				val = instantiateDslLocals(env, args[1]);
				nenv = DslEnv(env with locals = setTree(env.locals, let, var(let)));
				DslNode(name, [args[0], val, 
					instantiateDslLocals(nenv, args[2])
				], pos);
			} else if (name == "var") {
				lookupTreeDef(env.locals, getDslString(args[0]), p);
			} else if (name == "lambda") {
				largs = getDslList(args[0]);
				nlocals : Tree<string, DslAst> = foldList(largs, env.locals, \acc, darg -> {
					arg = getDslString(darg);
					setTree(acc, arg, DslNode("var", [darg], pos))
				});
				newBody = instantiateDslLocals(DslEnv(env with locals = nlocals), args[1]);
				DslNode(name, [args[0], newBody], pos)
			} else {
				// Normal functions
				eargs = map(args, \a -> {
					instantiateDslLocals(env, a);
				});
				DslNode(name, eargs, pos);
			}
		}
		DslList(value): {
			DslList(mapList(value, \v -> instantiateDslLocals(env, v)));
		}
		DslBool(value): p;
		DslInt(value): p;
		DslDouble(value): p;
		DslString(value): p;
	}
}

unquoteDsl(env : DslEnv, p : DslAst) -> DslAst {
	switch (p) {
		DslNode(name, args, pos): {
			if (name == "bind") {
				let = getDslString(args[0]);
				if (let == "") {
					evaluateDsl(env, args[0]);
				} else {
					lookupTreeDef(env.locals, let, p);
				}
			} else {
				// Normal functions
				eargs = map(args, \a -> {
					unquoteDsl(env, a);
				});
				DslNode(name, eargs, pos);
			}
		}
		DslList(value): {
			DslList(mapList(value, \v -> unquoteDsl(env, v)));
		}
		DslBool(value): p;
		DslInt(value): p;
		DslDouble(value): p;
		DslString(value): p;
	}
}

DslNativeBuiltin(
	fn : (([DslAst]) -> DslAst)
);

builtinNativeDsls : ref Maybe<Tree<string, DslNativeBuiltin>> = ref None();

getDslNative(name : string) -> Maybe<DslNativeBuiltin> {
	two = \fn : (DslAst, DslAst) -> DslAst -> {
		DslNativeBuiltin(\args -> fn(args[0], args[1]))
	};
	one = \fn : (DslAst) -> DslAst -> {
		DslNativeBuiltin(\args -> fn(args[0]));
	};
	n : Tree<string, DslNativeBuiltin> = onlyOnce(builtinNativeDsls, \ -> {
		pairs2tree([
			Pair("add", two(addDsl)),
			Pair("sub", two(subDsl)),
			Pair("mul", two(mulDsl)),
			Pair("div", two(divDsl)),
			Pair("mod", two(modDsl)),
			Pair("equal", two(equalDsl)),
			Pair("not_equal", two(notEqualDsl)),
			Pair("less", two(lessDsl)),
			Pair("less_equal", two(lessEqualDsl)),
			Pair("greater", two(greaterDsl)),
			Pair("greater_equal", two(greaterEqualDsl)),
			Pair("not", one(notDsl)),
			Pair("negate", one(negateDsl)),

			Pair("cons", two(consDsl)),
			Pair("nil", DslNativeBuiltin(\args -> {
				// println("Calling nil with " + toString(args));
				DslList(makeList())
			})),
			Pair("head", one(headDsl)),
			Pair("tail", one(tailDsl)),
			Pair("brace", one(braceDsl)),

			// Get the name of a node
			Pair("nodeName", one(nodeNameDsl)),
			// Get child #n of a node
			Pair("nodeChild", two(nodeChildDsl)),
			// Make a node
			Pair("makeNode", two(makeNodeDsl)),
			Pair("println", one(printlnDsl)),
		])
	});
	lookupTree(n, name);
}

addDsl(left : DslAst, right : DslAst) -> DslAst {
	keep = \ -> DslNode("add", [left, right], 0);
	error = \ -> {
		println("Can not add " + prettyDsl(left) + " and " + prettyDsl(right));
		keep();
	}

	switch (left) {
		DslBool(value): error();
		DslInt(lvalue): {
			switch (right) {
				DslInt(rvalue): DslInt(lvalue + rvalue);
				DslDouble(rvalue): DslDouble(i2d(lvalue) + rvalue);
				DslString(rvalue): DslString(i2s(lvalue) + rvalue);
				default: keep();
			}
		}
		DslDouble(lvalue): {
			switch (right) {
				DslInt(rvalue): DslDouble(lvalue + i2d(rvalue));
				DslDouble(rvalue): DslDouble(lvalue + rvalue);
				DslString(rvalue): DslString(d2s(lvalue) + rvalue);
				default: keep();
			}
		}
		DslString(lvalue): {
			switch (right) {
				DslInt(rvalue): DslString(lvalue + i2s(rvalue));
				DslDouble(rvalue): DslString(lvalue + d2s(rvalue));
				DslString(rvalue): DslString(lvalue + rvalue);
				default: keep();
			}
		}
		DslList(lvalue): error();
		DslNode(name, args, pos): keep();
	}
}

subDsl(left : DslAst, right : DslAst) -> DslAst {
	keep = \ -> DslNode("sub", [left, right], 0);
	error = \ -> {
		println("Can not subtract " + prettyDsl(left) + " and " + prettyDsl(right));
		keep();
	}
	switch (left) {
		DslBool(value): error();
		DslInt(lvalue): {
			switch (right) {
				DslInt(rvalue): DslInt(lvalue - rvalue);
				DslDouble(rvalue): DslDouble(i2d(lvalue) - rvalue);
				default: keep();
			}
		}
		DslDouble(lvalue): {
			switch (right) {
				DslInt(rvalue): DslDouble(lvalue - i2d(rvalue));
				DslDouble(rvalue): DslDouble(lvalue - rvalue);
				default: keep();
			}
		}
		DslString(lvalue): error();
		DslList(lvalue): error();
		DslNode(name, args, pos): keep();
	}
}

mulDsl(left : DslAst, right : DslAst) -> DslAst {
	keep = \ -> DslNode("mul", [left, right], 0);
	error = \ -> {
		println("Can not multiply " + prettyDsl(left) + " and " + prettyDsl(right));
		keep();
	}
	switch (left) {
		DslBool(value): error();
		DslInt(lvalue): {
			switch (right) {
				DslInt(rvalue): DslInt(lvalue * rvalue);
				DslDouble(rvalue): DslDouble(i2d(lvalue) * rvalue);
				default: keep();
			}
		}
		DslDouble(lvalue): {
			switch (right) {
				DslInt(rvalue): DslDouble(lvalue * i2d(rvalue));
				DslDouble(rvalue): DslDouble(lvalue * rvalue);
				default: keep();
			}
		}
		DslString(lvalue): error();
		DslList(lvalue): error();
		DslNode(name, args, pos): keep();
	}
}

divDsl(left : DslAst, right : DslAst) -> DslAst {
	keep = \ -> DslNode("div", [left, right], 0);
	error = \ -> {
		println("Can not divide " + prettyDsl(left) + " and " + prettyDsl(right));
		keep();
	}
	switch (left) {
		DslBool(value): error();
		DslInt(lvalue): {
			switch (right) {
				DslInt(rvalue): DslInt(lvalue / rvalue);
				DslDouble(rvalue): DslDouble(i2d(lvalue) / rvalue);
				default: keep();
			}
		}
		DslDouble(lvalue): {
			switch (right) {
				DslInt(rvalue): DslDouble(lvalue / i2d(rvalue));
				DslDouble(rvalue): DslDouble(lvalue / rvalue);
				default: keep();
			}
		}
		DslString(lvalue): error();
		DslList(lvalue): error();
		DslNode(name, args, pos): keep();
	}
}

modDsl(left : DslAst, right : DslAst) -> DslAst {
	keep = \ -> DslNode("mod", [left, right], 0);
	error = \ -> {
		println("Can not modulo " + prettyDsl(left) + " and " + prettyDsl(right));
		keep();
	}
	switch (left) {
		DslBool(value): error();
		DslInt(lvalue): {
			switch (right) {
				DslInt(rvalue): DslInt(lvalue % rvalue);
				DslDouble(rvalue): DslDouble(i2d(lvalue) % rvalue);
				default: keep();
			}
		}
		DslDouble(lvalue): {
			switch (right) {
				DslInt(rvalue): DslDouble(lvalue % i2d(rvalue));
				DslDouble(rvalue): DslDouble(lvalue % rvalue);
				default: keep();
			}
		}
		DslString(lvalue): error();
		DslList(lvalue): error();
		DslNode(name, args, pos): keep();
	}
}

compareDsl(left : DslAst, right : DslAst) -> int {
	genericCompare(left, right);
}

// Is this a value that is comparable at compile time?
isDslValue(e : DslAst) -> bool {
	switch (e) {
		DslBool(value): true;
		DslInt(value): true;
		DslDouble(value): true;
		DslString(value): true;
		DslList(value): foldList(value, true, \acc, l -> {
			acc && isDslValue(l);
		});
		DslNode(name, args, pos): {
			!contains([
				"ifelse", "let", "var", "lambda", "call", "and", "or", "quote", "bind"
			], name)
		}
	}
}

equalDsl(left : DslAst, right : DslAst) -> DslAst {
	if (isDslValue(left) && isDslValue(right)) {
		DslBool(compareDsl(left, right) == 0);
	} else {
		DslNode("equal", [left, right], 0);
	}
}

notEqualDsl(left : DslAst, right : DslAst) -> DslAst {
	if (isDslValue(left) && isDslValue(right)) {
		DslBool(compareDsl(left, right) != 0);
	} else {
		DslNode("not_equal", [left, right], 0);
	}
}

lessDsl(left : DslAst, right : DslAst) -> DslAst {
	if (isDslValue(left) && isDslValue(right)) {
		DslBool(compareDsl(left, right) < 0);
	} else {
		DslNode("less", [left, right], 0);
	}
}

lessEqualDsl(left : DslAst, right : DslAst) -> DslAst {
	if (isDslValue(left) && isDslValue(right)) {
		DslBool(compareDsl(left, right) <= 0);
	} else {
		DslNode("less_equal", [left, right], 0);
	}
}

greaterDsl(left : DslAst, right : DslAst) -> DslAst {
	if (isDslValue(left) && isDslValue(right)) {
		DslBool(compareDsl(left, right) > 0);
	} else {
		DslNode("greater", [left, right], 0);
	}
}

greaterEqualDsl(left : DslAst, right : DslAst) -> DslAst {
	if (isDslValue(left) && isDslValue(right)) {
		DslBool(compareDsl(left, right) >= 0);
	} else {
		DslNode("greater_equal", [left, right], 0);
	}
}

notDsl(val : DslAst) -> DslAst {
	keep = \ -> DslNode("not", [val], 0);
	error = \ -> {
		println("Can not not " + prettyDsl(val));
		keep();
	}
	switch (val) {
		DslBool(value): DslBool(!value);
		DslInt(value): error();
		DslDouble(value): error();
		DslString(value): error();
		DslList(value): error();
		DslNode(name, args, pos): keep();
	}
}

negateDsl(val : DslAst) -> DslAst {
	keep = \ -> DslNode("negate", [val], 0);
	error = \ -> {
		println("Can not negate " + prettyDsl(val));
		keep();
	}
	switch (val){
		DslBool(value): error();
		DslInt(value): DslInt(-value);
		DslDouble(value): DslDouble(-value);
		DslString(value): error();
		DslList(value): error();
		DslNode(name, args, pos): keep();
	}
}

consDsl(left : DslAst, right : DslAst) -> DslAst {
	rlist = getDslList(right);
	DslList(Cons(left, rlist));
}

headDsl(val : DslAst) -> DslAst {
	list = getDslList(val);
	switch (list) {
		EmptyList(): DslList(list);
		Cons(head, __): head;
	}
}

tailDsl(val : DslAst) -> DslAst {
	list = getDslList(val);
	DslList(switch (list) {
		EmptyList(): list;
		Cons(head, tail_): tail_;
	})
}

braceDsl(val : DslAst) -> DslAst {
	switch (val) {
		DslList(l): {
			// There is debate as to whether to keep others
			// when elements are not values, but it seems this
			// is best after all
			headList(l, val)
		}
		default: val;
	}
}

nodeNameDsl(val : DslAst) -> DslAst {
	node = getDslNode(val);
	DslString(node.name);
}

nodeChildDsl(val : DslAst, n : DslAst) -> DslAst {
	node = getDslNode(val);
	i = getDslInt(n);
	elementAt(node.args, i, val)
}

makeNodeDsl(name : DslAst, args : DslAst) -> DslAst {
	DslNode(
		getDslString(name),
		list2array(getDslList(args)),
		0
	)
}

printlnDsl(val : DslAst) -> DslAst {
	println(prettyDsl(val));
	val;
}
