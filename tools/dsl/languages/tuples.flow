import tools/dsl/dsl_parse;

export {
	// This adds tuples to a language
	// Syntax:
	// () is the null-tuple, represented as nil()
	// ( 1, ) is the one-tuple, represented as cons(1, nil())
	// ( 1, 2 ) is pair, represented as cons(2, cons(1, nil()))
	// a.first => first(a) peels until the last element of a list
	// a.second => second(a) peels until the second last element of a list
	defineTuples(language : DslLanguage) -> DslLanguage;
}

defineTuples(language : DslLanguage) -> DslLanguage {
	tuples = extendGrammar(language.grammar, << 
		atom = atom | '(' ws ')' ws $"nil" $"tuple_1" |
			'(' ws $"nil" exp "," ws $"cons" ')' $"tuple_1"
			| '(' ws exps  ')' $"tuple_1";
	>>);

	// TODO: Add standard library implementations of first, second, third, ...

	// Have an "nth"

	println(prettyDsl(parseProgram("test-tuples", tuples, <<
		a = ();
		b = (1,);
		c = (2,3);
		d = (4,5,6);
		b.first + c.second + d.third
	>>)));

	DslLanguage(language with name = "tuples", grammar = tuples)
}

/*
// Count from the start
listAt(xs, i, x0) {
	if (i < 0) x0
	else switch (xs : List) {
				EmptyList(): x0;
				Cons(h, t): if (i == 0) h else listAt(t, i - 1, x0);
	};
}

nth(l : List<?>, n : int, acc : ?) -> ? {
	if (n == 0) {
		headList(l, acc);

	}
}
*/