import tools/dsl/dsl_pretty;
import tools/dsl/dsl_util;
import ds/egraph_matching;

export {
	egraphDslReplacements(program : DslAst, def : DslAst, rules : DslAst, iterations : int) -> DslAst;
}

dslRules2replacements(rules : DslAst) -> [EReplacement<DslAst>] {
	error = \ -> {
		println("Expected rule, got " + prettyDsl(rules));
		[];
	}
	switch (rules) {
		DslBool(value): error();
		DslInt(value): error()
		DslDouble(value): error()
		DslString(value): error()
		DslList(value): {
			foldList(value, [], \acc, val -> {
				concat(acc, dslRules2replacements(val))
			});
		}
		DslNode(name, args, pos): {
			if (name == "rule") {
				pattern = dsl2pattern(args[0]);
				replacement = args[1];
				[
					EReplacement(pattern, \bindings : Tree<string, DslAst> -> {
						replaceDsl(bindings, replacement)
					})
				];
			} else error();
		}
	}
}

dsl2pattern(ast : DslAst) -> EPattern<DslAst> {
	switch (ast) {
		DslBool(value): EPatternTerm(ast, []);
		DslInt(value): EPatternTerm(ast, []);
		DslDouble(value): EPatternTerm(ast, []);
		DslString(value): EPatternTerm(ast, []);
		DslList(value): EPatternTerm(DslList(makeList()), map(list2array(value), dsl2pattern));
		DslNode(name, args, pos): {
			if (name == "bind") {
				bind = getDslString(args[0]);
				EPatternVar(bind)
			} else {
				EPatternTerm(
					DslNode(name, [], pos),
					map(args, dsl2pattern)
				)
			}
		}
	}
}

replaceDsl(bindings : Tree<string, DslAst>, ast : DslAst) -> DslAst {
	switch (ast) {
		DslBool(value): ast;
		DslInt(value): ast;
		DslDouble(value): ast;
		DslString(value): ast;
		DslList(value): {
			DslList(mapList(value, \val : DslAst -> {
				replaceDsl(bindings, val)
			}))
		}
		DslNode(name, args, pos): {
			if (name == "bind") {
				bind = getDslString(args[0]);
				mvalue = lookupTree(bindings, bind);
				mvalue ?? {
					// println("Replaced " + bind + " with " + prettyDsl(mvalue));
					mvalue;
				} : {
					println("Unknown binding in replacement " + bind);
					ast;
				}
			} else {
				DslNode(name, map(args, \a -> replaceDsl(bindings, a)), pos);
			}
		}
	}
}


buildDslEGraph(ast : DslAst) -> Pair<EGraph<DslAst>, int> {
	splitChildren = \a : DslAst -> switch (a) {
		DslBool(value): Pair(a, []);
		DslInt(value): Pair(a, []);
		DslDouble(value): Pair(a, []);
		DslString(value): Pair(a, []);
		DslList(value): Pair(DslList(makeList()), list2array(value));
		DslNode(name, args, pos): Pair(DslNode(name, [], pos), args);
	};
	egraph = makeEGraph(splitChildren);
	Pair(egraph, addEExp(egraph, ast));
}

buildDslEMatchEngine(program : DslAst, def : DslAst) -> Pair<EMatchEngine<DslAst>, int> {
	egraph = buildDslEGraph(program);
	combine = \head : DslAst, args : [DslAst] -> {
		switch (head) {
			DslBool(value): head;
			DslInt(value): head;
			DslDouble(value): head;
			DslString(value): head;
			DslList(value): DslList(array2list(args));
			DslNode(name, __, pos): DslNode(name, args, pos);
		}
	};
	Pair(makeEMatchEngine(egraph.first, def, combine), egraph.second);
}

egraphDslReplacements(program : DslAst, def : DslAst, rules : DslAst, iterations : int) -> DslAst {
	match = buildDslEMatchEngine(program, def);

	replacements = dslRules2replacements(rules);

	performEReplacements(match.first, iterations, match.second, replacements);

	// TODO: Do extraction
	program;
}
