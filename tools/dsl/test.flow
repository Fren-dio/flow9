import tools/dsl/dsl;
import tools/dsl/dsl_pattern;

main() {
	// The grammar of the language where arity of actions is a naming convention
	mylang = defineGrammar("mylang", <<
		exp = exp "+" ws exp $"plus_2" 
			|> exp "*" ws exp $"mul_2"
			|> $int ws $"s2i"
			|> $id ws $"bind_1";	// For pattern matching
		int = '0'-'9'+;
		id = 'a'-'z'+;

		ws = s*;
		s = cs+;
		anychar = '0x0000'-'0xffff';
		cs = " " | "\t" | "\n" | "//" (!"\n" anychar)* "\n" | "/*" (!"*/" anychar)* "*/" | "\r";
		lastLineComment = "//" (!"\n" anychar)*;
		ws exp
	>>);

	// The set of rewriting rules we want
	rules = parseRules(mylang, <<
		a + b => b + a;
		a * b => b * a;
		a + 0 => a;
		a * 0 => 0;
		a * 1 => a;
	>>);

	// For the plumbing to work with the rewrite engine, we need a default value (in the language syntax)
	defaultValue : DslAst = parseProgram(mylang, << 0 >>);

//	testValue = parseProgram(mylang, << 0 + 123 + 0 * 23 + 1 * 23 >>);
	testValue = parseProgram(mylang, << 0 + 123  >>);

	// These costs refer to the semantic actions without arity
	// so we can figure out what the costs are. This is used to extract the best reduction
	costs = rewriteCosts(<<
		int => 1;
		plus => 2;
		mul => 3;
	>>);

	replaces = egraphDslReplacements(testValue, defaultValue, rules.rules, 2);

	// This is a prototype for how to define an compiler/evaluator of a language.
	// Probably, we need some conversion method for instantiation
	compiler = makeCompiler(mylang, "text", <<
		plus(a, b) => plus_int($a, $b);
		mul(a, b) = mul_int($a, $b);
		int(n) = n;
	>>);


	println("Done");
	quit(0);
}
