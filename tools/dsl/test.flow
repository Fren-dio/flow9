import tools/dsl/dsl_parse;
import tools/dsl/dsl_rewrite;
import tools/dsl/dsl_compiler;
import tools/dsl/dsl_eval;

main() {
	// The grammar of the language where arity of actions is a naming convention
	mylang = defineGrammar("mylang", <<
		exp = 
			id "=" ws exp ";" ws exp $"let_3"
			|> exp "||" ws exp $"or_2"
			|> exp "&&" ws exp $"and_2"
			|> exp "==" exp $"equal_2" | exp "!=" ws exp $"not_equal_2"
			|> exp ("<=" ws exp $"less_equal_2" | "<" ws exp $"less_2" | ">=" ws exp $"greater_equal_2" | ">=" ws exp $"greater_2")

			|> exp < ("+" ws exp $"add_2" | "-" ws exp $"sub_2")*
			|> exp ("*" ws exp $"mul_2" | "/" ws exp $"div_2" | "%"  ws exp $"mod_2")*

			|> (
				'!' ws exp $"not_1"
				| "-" ws exp $"negate_1"
				| lambda
				| exp (
					( "(" ws exps ")" ws $"call_2")
					// | "." ws id $"dot_2"
					// | "[" ws exp "]" ws $"index_2"
				)*
			)

			|> "{" ws expsemi "}" ws $"brace_1"
			|> "(" ws exp ")" ws
			|> (
				"if" !letterOrDigit ws exp exp "else" ws exp $"ifelse_3"
				| "true" !letterOrDigit $"true" ws
				| "false" !letterOrDigit $"false" ws
				| id $"var_1"
				|> $int ws $"s2i"
				|> "$" ws id $"bind_1"	// For pattern matching
			);

		lambda = '\' ws lambdaargs "->" ws exp "" $"lambda_2"; // The "" makes right-recursion disappear
			lambdaargs = $"nil" id $"cons" ("," ws id $"cons")*
				| $"nil";

		exps = $"nil" exp $"cons" ("," ws exp $"cons")* ("," ws)? 
			| $"nil";

		expsemi = $"nil" exp $"cons" (";" ws exp $"cons")* (";" ws)? 
			| $"nil";
	
		int = '0'-'9'+;
		id = $(('a'-'z' | 'A'-'Z' | '_') letterOrDigit*) ws;

		letterOrDigit = 'a'-'z'
			| 'A'-'Z'
			| '_'
			| '0'-'9';

		ws exp
	>>, true); // true adds definitions for whitespace

	// The set of rewriting rules we want
	rules = parseRules(mylang, <<
		$a + $b => $b + $a;
		$a * $b => $b * $a;
		$a + $a => 2 * $a;
		2 * $a => $a + $a;
		$a + 0 => $a;
		$a * 0 => 0;
		$a * 1 => $a;
	>>);

	// For the plumbing to work with the rewrite engine, we need a default value (in the language syntax)
	defaultValue : DslAst = parseProgram(mylang, << 0 >>);

	// These costs refer to the semantic actions without arity
	// so we can figure out what the costs are. This is used to extract the best reduction
	costs = rewriteCosts(<<
		int => 1;
		add => 2;
		sub => 2;
		mul => 3;
		div => 4;
	>>);

	//
	// This is the program to test
	//

	testValue = parseProgram(mylang, << 
		add = \b, c -> b + c;
		if true add(2, 3) + 3 * 1 - (1 * 2 - 3 + 0 * 4) else 0
	>>);

	replaced = rewriteDsl(testValue, defaultValue, rules.rules, costs.costs, 2);

	if (false) {
		println(prettyDsl(testValue));
		println("is optimized to\n");
		println(prettyDsl(replaced));
		// 123 + 23 + 34 + 34
	}

	// This is a prototype for how to define an compiler/evaluator of a language.
	// Probably, we need some conversion method for instantiation
	compiler = makeCompiler(mylang, "text", <<
		ifelse(a, b, c) => $a(5) "?" $b(5) ":" $c(5);
		add(a, b) => $a(40) "+" $b(39);
		sub(a, b) => $a(40) "-" $b(39);
		mul(a, b)  => $a(50) "*" $b(49);
	>>);

	program = compileDsl(compiler, replaced);
	println("The program   " + prettyDsl(testValue) + "   compiles to " + program);

	println("It evaluates to " + prettyDsl(evaluateDsl(makeDslEnv(), testValue)));

	if (true) {
		programs = [<< 1 + 2 * 3 >>, << (1 + 2) * 3 >>, << 1 - 2 - 3 >>, << (1 - 2) - 3 >>, << 1 - (2 - 3) >>];
		iter(programs, \p -> {
			program2 = parseProgram(mylang, p);
			println("Testing precedence and associativity: " + p + " => " + compileDsl(compiler, program2) + "  =  " + prettyDsl(evaluateDsl(makeDslEnv(), program2)));
		});
	}

	println("Done");
	quit(0);
}
