import tools/dsl/dsl;

main() {
	// The grammar of the language where arity of actions is a naming convention
	mylang = defineGrammar("mylang", << 
		exp = exp "+" exp $"plus_2" 
			|> exp "*" exp $"mul_2") 
			|> $int $"int_1"
			|> $id $"bind_1";	// For pattern matching
		int = '0'-'9'+;
		id = 'a'-'z';
	>>);

	// The set of rewriting rules we want
	rules = parseRules(mylang, <<
		a + b => b + a;
		a * b => b * a;
		a + 0 => a;
		a * 0 => 0;
		a * 1 => a;
	>>);

	// For the plumbing to work with the rewrite engine, we need a default value (in the language syntax)
	defaultValue = parseProgram(mylang, << 0 >>);

	// These costs refer to the semantic actions without arity
	// so we can figure out what the costs are. This is used to extract the best reduction
	costs = rewriteCosts(<<
		int => 1;
		plus => 2;
		mul => 3;
	>>);

	// This is a prototype for how to define an compiler/evaluator of a language.
	// Probably, we need some conversion method for instantiation
	compiler = makeCompiler(mylang, "text", <<
		plus(a, b) => plus_int($a, $b);
		mul(a, b) = mul_int($a, $b);
		int(n) = n;
	>>);
}
