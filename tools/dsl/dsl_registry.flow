import tools/dsl/dsl_transformation;
import ds/tree;
import string;

export {
	// Facility to register transformations for the language facility
	registerDslTransformation(d : DslTransformation) -> void;

	// For extensions of transformations, this provides a way to find existing ones
	findDslTransformations(phase : string, specification : string) -> [DslTransformation];

	// Perform this transformations to this input, doing all that is required
	performDslTransformations(phase : string, toLanguage : string, input : DslAstEnv) -> DslAstEnv;
}

// Lookup from phase to transformations
dslTransformationsPhases : ref Tree<string, [DslTransformation]> = ref makeTree();

registerDslTransformation(d : DslTransformation) -> void {
	dslTransformationsPhases := treePushToArrayValue(^dslTransformationsPhases, d.phase, d);
}

findDslTransformations(phase : string, specification : string) -> [DslTransformation] {
	transforms = getTreeArrayValue(^dslTransformationsPhases, phase);
	filter(transforms, \tr -> {
		tr.specification == specification
	});
}

performDslTransformations(phase : string, toLanguage : string, input : DslAstEnv) -> DslAstEnv {
	transforms = getTreeArrayValue(^dslTransformationsPhases, phase);
	iterate = fold(transforms, input, \acc, transformation -> {
		// Are we done?
		if (acc.language == toLanguage) acc
		else {
			// What would be the result?
			result = resultDslTransformation(acc.language, transformation.specification);
			if (result != acc.language) {
				// OK, it does something
				performDslTransformation(acc, transformation);
			} else acc;
		}
	});
	if (iterate.language == toLanguage) {
		// We made it!
		iterate
	} else if (iterate.language != input.language) {
		// OK, continue
		performDslTransformations(phase, toLanguage, iterate)
	} else {
		println("Could not transform to " + toLanguage + ". Only got to " + iterate.language);
		iterate;
	}
}

// Applies the given transformation
performDslTransformation(input : DslAstEnv, transformation : DslTransformation) -> DslAstEnv {
	res = transformation.fn(input);
	// Make sure to update the language as well
	result = resultDslTransformation(input.language, transformation.specification);
	DslAstEnv(
		res
		with language = result
	)		
}

// Calculate the effect of this specification to this language
// See dsl_transformation.flow for a description of these specs
// and their effects
resultDslTransformation(language : string, specification : string) -> string {
	spec = strReplace(specification, "|", "");
	if (endsWith(language, spec)) {
		// OK, it matches
		// Introduce the cut point
		cut = strReplace(language, spec, specification);
		takeBefore(cut, "|", cut)
	} else language;
}
