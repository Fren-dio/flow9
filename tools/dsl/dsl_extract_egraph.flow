
import tools/dsl/dsl_egraph;
import math/math;

export {
	// Extracts the best AST node for each class
	extractDslEGraph(
		e : DslEGraph,
		// What language are we looking at?
		specification : string,
		// The cost per AST node name
		costs : Tree<string, int>,
	) -> Tree<int, DslEClassCost>;

	DslEClassCost(
		// The cost of this. The smaller, the better
		cost : int,
		// The node that wins
		node : DslENode
	);
}

DslExtractorEnv(
	egraph : DslEGraph,
	// Function to extract the best alternative and the cost of that
	nodeCosts : Tree<string, int>,
	// The lowest cost so far per class
	costs : ref Tree<int, DslEClassCost>,
	// What eclasses are we currently extracting? Attempt to avoid infinite loops
	extracting : ref Set<int>,
);

// https://github.com/egraphs-good/egg/blob/main/src/extract.rs
extractDslEGraph(
		e : DslEGraph,
		// What language are we looking at?
		specification : string,
		// The cost per AST node name
		costs : Tree<string, int>,
	) -> Tree<int, DslEClassCost> {
	env = DslExtractorEnv(e, costs, ref makeTree(), ref makeSet());
	calcDslEClassCosts(env);
	^(env.costs);
}

calcDslEClassCosts(e : DslExtractorEnv) -> void {
	work = ref false;
	iterDslEGraph(e.egraph, \eclass : int, nodes : Set<DslENode> -> {
		getDslEClassCost(e, eclass);
		{}
	});
	if (^work) {
		calcDslEClassCosts(e);
	}
}

getDslEClassCost(env : DslExtractorEnv, eclass : int) -> Maybe<DslEClassCost> {
	mcost = lookupTree(^(env.costs), eclass);
	mcost ?? {
		Some(mcost)
	} : {
		if (containsSet(^(env.extracting), eclass)) None()
		else {
			env.extracting := insertSet(^(env.extracting), eclass);
			nodes = getDslEClassNodes(env.egraph, eclass);
			res = foldSet(nodes, mcost, \acc, node : DslENode -> {
				ncost = getDslENodeCost(env, node);
				switch (ncost) {
					None(): acc;
					Some(cost): {
						switch (acc) {
							None(): {
								classCost = DslEClassCost(cost, node);
								env.costs := setTree(^(env.costs), eclass, classCost);
								Some(classCost);
							}
							Some(ec): {
								if (cost < ec.cost) {
									classCost = DslEClassCost(cost, node);
									env.costs := setTree(^(env.costs), eclass, classCost);
									Some(classCost);
								} else acc;
							}
						}
					}
				}
			});
			env.extracting := removeSet(^(env.extracting), eclass);

			res;
		}
	}
}

getDslENodeCost(env : DslExtractorEnv, node : DslENode) -> Maybe<int> {
	childcosts : [DslEClassCost] = filtermap(node.args, \arg -> {
		getDslEClassCost(env, arg)
	});
	if (length(childcosts) == length(node.args)) {
		// if (matchDslSpecification)
		nodeCost = dslCost(env.nodeCosts, node.value);
		totalCost = fold(childcosts, nodeCost, \acc, cc -> {
			acc + cc.cost;
		});
		Some(totalCost)
	} else None();
}


dslCost(costs : Tree<string, int>, a : DslAst) -> int {
	switch (a) {
		DslBool(value): lookupTreeDef(costs, "bool", 1);
		DslInt(value): lookupTreeDef(costs, "int", 1);
		DslDouble(value): lookupTreeDef(costs, "double", 1);
		DslString(value): lookupTreeDef(costs, "string", 1);
		DslList(value): lookupTreeDef(costs, "list", 1);
		DslNode(name, args, pos): lookupTreeDef(costs, name, 1);
	}
}

/*

extractDsl(egraph : EGraph<DslAst>, extracts : Tree<int, EClassCost<DslAst>>, eclass : int) -> DslAst {
	root = getEClassRoot(egraph, eclass);
	mextract = lookupTree(extracts, root);
	mextract ?? {
		node : ENode<DslAst> = mextract.node;
		children = map(node.args, \a : int -> {
			extractDsl(egraph, extracts, a);
		});
		combineDsl(node.head, children)
	} : {
		nodes : Set<ENode<DslAst>> = getUnionMapValue(egraph.eclass, eclass);
		println("Could not resolve " + i2s(eclass) + " with " + superglue(set2array(nodes), \n : ENode<DslAst> -> prettyDsl(n.head), ", "));
		DslNode("Could not resolve " + i2s(eclass), [], 0)
	}
}

*/
