import tools/dsl/dsl_parse;

export {
	defineWase() -> DslGrammar;	
}

defineWase() -> DslGrammar {
	/*
	TODO:
	"native" id ":" optmutable type "=" id "." id; <scope>  $"import_5"

	"block" "{" expsemi "}"
	"loop" "{" expsemi "}"
	"break" (int | $$"0")
	id "<" wargs ">" ("(" exps ")" | $"nil") $"wasm_op_3"
		wargs = $"nil" warg $"cons"("," warg $"cons")* | $"nil";
		warg = type | id "." id | id | int | "[" wargs "]";

	switch at some point down the line

	import table, memory

	*/
	grammar = defineGrammar("wase", <<
		decl = global | function | $"empty_0";

		global = optexport id $"swap" 
				":" ws optmutable type $"swap"
				"=" ws exp ";" ws decl $"global_6"; // (id, export : bool, type, mutable : bool, exp, body, scope)

		// function(id, export : bool, args : [idtype(id, type)], [returnTypes], body, scope)
		function = optexport id $"swap" "(" ws lambdaargs ")" ws "->" ws typelist exp decl $"function_6"; // The "" makes right-recursion disappear

			lambdaargs = $"nil" id ":" ws type $"idtype_2" $"cons" ("," ws id ":" ws type $"idtype_2" $"cons")*
				| $"nil";

		exp = 
			id ":" ws type "=" ws exp ";" ws expsemi $"brace_1" $"let_4"
			|> exp "|" ws exp $"or_2"
			|> exp "&" ws exp $"and_2"
			|> exp "==" ws exp $"equal_2" | exp "!=" ws exp $"not_equal_2" | exp "is" ws "null" ws $"is_null_1"
			|> exp ("<=" ws exp $"less_equal_2" | "<" ws exp $"less_2" | ">=" ws exp $"greater_equal_2" | ">" ws exp $"greater_2")

			|> exp < ("+" ws exp $"add_2" | "-" ws exp $"sub_2")*
			|> exp ("*" ws exp $"mul_2" | "/u" ws exp $"divu_2" | "/" ws exp $"div_2" 
					| "%u"  ws exp $"modu_2" | "%"  ws exp $"mod_2")*

			|> (
				// '!' ws exp $"not_1"
				// | "-" ws exp $"negate_1"
				exp (
					postfix
				)*
			)

			|> "{" ws expsemi "}" ws $"brace_1"
			|> "(" ws exp ")" ws
			|> atom;

		// Give this a name, so it can be extended
		postfix = ( "(" ws exps ")" ws $"call_2");

		atom = "if" !letterOrDigit ws exp exp "else" ws exp $"ifelse_3"
				| "true" !letterOrDigit $$"1" $"s2i" $"int" ws
				| "false" !letterOrDigit $$"0" $"s2i" $"int" ws
				| "return" ws (exp | $"nil") $"return_1"
				| id ":=" ws exp $"set_2"
				| id $"var_1"
				| '[' ws exps ']' ws $"reverse"	// list
//				| string $"string_1"
				| double $"double_1"
				| int $"int_1"
				| '<<' $(!('>' '>') anychar)* ('>' '>') ws
				;

		exps = $"nil" exp $"cons" ("," ws exp $"cons")* ("," ws)? 
			| $"nil";

		expsemi = $"nil" exp $"cons" (";" ws exp $"cons")* (";" ws)? 
			| $"nil";

		optexport = ("export" ws $$"1" | $$"0") $"s2i";

		optmutable = ("mutable" ws $$"1" | $$"0" ) $"s2i";

		type = $("i32" | "i64" | "f32" | "f64" | "v128" | "func" | "extern" | "auto") $"type_1" ws;

		typelist = "(" ws types ")" ws | $"nil" type $"cons";

		types = $"nil" type $"cons" ("," ws type $"cons")* | $"nil";

		fntype = "(" ws types ")" ws "->" ws typelist $"fntype_2"
			| id "<" ws types ">" ws $"partype_2"
			| valtype;

	
		ws decl
	>>, ["ws", "id", "int", "double", "string"]); // true adds definitions for whitespace

	grammar;
}
