import tools/dsl/dsl_runtime_common;
import tools/dsl/registry/dsl_populate;

import tools/dsl/wase/wase;

export {
	// After type inference, we can lower to Wase
	dsl2wase(d : DslAst) -> Wase;
}

dsl2wase(d : DslAst) -> Wase {
	switch (d) {
		DslNode(name, args, pos): {
			b = \i -> getDslInt(args[i]) != 0;
			s = \i -> getDslString(args[i]);
			rec = \i -> dsl2wase(args[i]);
			valtype = \i -> dsl2WasmValType(args[i]);
			expr = \i -> dsl2WaseExpr(args[i]);
			i = \n -> getDslInt(args[n]);
			if (name == "global") {
				WaseGlobal(s(0), if (b(1)) s(0) else "", valtype(2), b(3), expr(4), rec(5))
			} else if (name == "function") {
				fnargs = list2array(getDslList(args[2]));
				rets = list2array(getDslList(args[3]));

				argTypes = map(fnargs, \fnarg -> {
					node = getDslNode(fnarg);
					dsl2WasmValType(node.args[1]);
				});
				retTypes = map(rets, dsl2WasmValType);
				fntype = WasmFuncType(argTypes, retTypes);

				body = expr(4);

				fnname = s(0);

				// TODO: Should we also extract the locals from the body?

				// Grab the arguments
				locals = map(fnargs, \fnarg -> {
					node = getDslNode(fnarg);
					argname = getDslString(node.args[0]);
					WaseLocal(argname, dsl2WasmValType(node.args[1]));
				});

				WaseFunction(fnname, if (b(1)) fnname else "", fnname == "main", fntype, locals, expr(4), rec(5))
			} else if (name == "empty") {
				WaseEmpty()

			} else {
				println("TODO: Compile " + prettyDsl(d) + " to wase");
				WaseEmpty()
			}
		}
		default: {
			println("Expected node, not " + prettyDsl(d));
			WaseEmpty()
		}
	}
}

dsl2WaseExpr(d : DslAst) -> WaseExpr {
	WaseExpr(dsl2WaseInstruction([], d))
}

dsl2WaseInstruction(acc : [WaseInstruction], d : DslAst) -> [WaseInstruction] {
	todo = \ -> {
		println("TODO: Compile " + prettyDsl(d) + " to wase expr");
		acc
	}
	// println("Compiling " + prettyDsl(d));
	switch (d) {
		DslBool(value): arrayPush(acc, WasmI32Const(b2i(value)));
		DslInt(value): arrayPush(acc, WasmI32Const(value));
		DslDouble(value): arrayPush(acc, WasmF64Const(value));
		DslString(value): todo(); 
		DslList(value): {
			foldList(value, acc, dsl2WaseInstruction)
		}
		DslNode(name, args, pos): {
			if (name == "int" || name == "double") {
				dsl2WaseInstruction(acc, args[0])
			} else if (name == "brace") {
				exps = list2array(getDslList(args[0]));
				foldi(exps, acc, \i, acc2, e -> {
					res = dsl2WaseInstruction(acc2, e);
					if (i + 1 != length(exps)) {
						type = waseType(e);
						switch (type) {
							DslList(l): {
								// Drop as many as the tuple has
								foldList(l, res, \acc3, __ -> {
									arrayPush(acc3, WasmDrop())	
								})
							}
							default: {
								arrayPush(res, WasmDrop())
							}
						}

					} else res
				})
			} else if (name == "var") {
				arrayPush(acc, WaseGet(getDslString(args[0])))
			} else if (name == "call") {
				fnadded = dsl2WaseInstruction(acc, args[0]);
				if (length(acc) + 1 != length(fnadded)) {
					println("Can not call " + prettyDsl(d));
				}
				fn = lastElement(fnadded, WasmUnreachable());
				callargs = dsl2WaseInstruction(acc, args[1]);
				arrayPush(callargs, WaseCall(fn));
			} else if (name == "add") {
				restype = dsl2WasmValType(args[2]);
				nacc = fold(subrange(args, 0, 2), acc, dsl2WaseInstruction);
				if (restype == WasmI32Type()) arrayPush(nacc, WasmI32Add())
				else if (restype == WasmI64Type()) arrayPush(nacc, WasmI64Add())
				else if (restype == WasmF32Type()) arrayPush(nacc, WasmF32Add())
				else if (restype == WasmF64Type()) arrayPush(nacc, WasmF64Add())
				else {
					println("TODO: Figure out add of type " + toString(restype));
					nacc;
				}
			} else if (name == "sub") {
				restype = dsl2WasmValType(args[2]);
				nacc = fold(subrange(args, 0, 2), acc, dsl2WaseInstruction);
				if (restype == WasmI32Type()) arrayPush(nacc, WasmI32Sub())
				else if (restype == WasmI64Type()) arrayPush(nacc, WasmI64Sub())
				else if (restype == WasmF32Type()) arrayPush(nacc, WasmF32Sub())
				else if (restype == WasmF64Type()) arrayPush(nacc, WasmF64Sub())
				else {
					println("TODO: Figure out sub of type " + toString(restype));
					nacc;
				}
			} else if (name == "mul") {
				restype = dsl2WasmValType(args[2]);
				nacc = fold(subrange(args, 0, 2), acc, dsl2WaseInstruction);
				if (restype == WasmI32Type()) arrayPush(nacc, WasmI32Mul())
				else if (restype == WasmI64Type()) arrayPush(nacc, WasmI64Mul())
				else if (restype == WasmF32Type()) arrayPush(nacc, WasmF32Mul())
				else if (restype == WasmF64Type()) arrayPush(nacc, WasmF64Mul())
				else {
					println("TODO: Figure out mul of type " + toString(restype));
					nacc;
				}
			} else if (name == "div") {
				restype = dsl2WasmValType(args[2]);
				nacc = fold(subrange(args, 0, 2), acc, dsl2WaseInstruction);
				if (restype == WasmI32Type()) arrayPush(nacc, WasmI32Div_s())
				else if (restype == WasmI64Type()) arrayPush(nacc, WasmI64Div_s())
				else if (restype == WasmF32Type()) arrayPush(nacc, WasmF32Div())
				else if (restype == WasmF64Type()) arrayPush(nacc, WasmF64Div())
				else {
					println("TODO: Figure out div of type " + toString(restype));
					nacc;
				}
			} else if (name == "divu") {
				restype = dsl2WasmValType(args[2]);
				nacc = fold(subrange(args, 0, 2), acc, dsl2WaseInstruction);
				if (restype == WasmI32Type()) arrayPush(nacc, WasmI32Div_u())
				else if (restype == WasmI64Type()) arrayPush(nacc, WasmI64Div_u())
				else {
					println("TODO: Figure out unsigned div of type " + toString(restype));
					nacc;
				}
			} else if (name == "mod") {
				restype = dsl2WasmValType(args[2]);
				nacc = fold(subrange(args, 0, 2), acc, dsl2WaseInstruction);
				if (restype == WasmI32Type()) arrayPush(nacc, WasmI32Rem_s())
				else if (restype == WasmI64Type()) arrayPush(nacc, WasmI64Rem_s())
				else {
					println("TODO: Figure out modulo of type " + toString(restype));
					nacc;
				}
			} else if (name == "modu") {
				restype = dsl2WasmValType(args[2]);
				nacc = fold(subrange(args, 0, 2), acc, dsl2WaseInstruction);
				if (restype == WasmI32Type()) arrayPush(nacc, WasmI32Rem_u())
				else if (restype == WasmI64Type()) arrayPush(nacc, WasmI64Rem_u())
				else {
					println("TODO: Figure out unsigned modulo of type " + toString(restype));
					nacc;
				}

			} else if (name == "equal") {
				argtype = dsl2WasmValType(waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, dsl2WaseInstruction);
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32Eq())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64Eq())
				else if (argtype == WasmF32Type()) arrayPush(nacc, WasmF32Eq())
				else if (argtype == WasmF64Type()) arrayPush(nacc, WasmF64Eq())
				else {
					println("TODO: Figure out equality of type " + toString(argtype));
					nacc;
				}
			} else if (name == "not_equal") {
				argtype = dsl2WasmValType(waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, dsl2WaseInstruction);
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32Ne())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64Ne())
				else if (argtype == WasmF32Type()) arrayPush(nacc, WasmF32Ne())
				else if (argtype == WasmF64Type()) arrayPush(nacc, WasmF64Ne())
				else {
					println("TODO: Figure out != of type " + toString(argtype));
					nacc;
				}
			} else if (name == "less_equal") {
				argtype = dsl2WasmValType(waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, dsl2WaseInstruction);
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32Le_s())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64Le_s())
				else if (argtype == WasmF32Type()) arrayPush(nacc, WasmF32Le())
				else if (argtype == WasmF64Type()) arrayPush(nacc, WasmF64Le())
				else {
					println("TODO: Figure out <= of type " + toString(argtype));
					nacc;
				}
			} else if (name == "less") {
				argtype = dsl2WasmValType(waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, dsl2WaseInstruction);
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32Lt_s())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64Lt_s())
				else if (argtype == WasmF32Type()) arrayPush(nacc, WasmF32Lt())
				else if (argtype == WasmF64Type()) arrayPush(nacc, WasmF64Lt())
				else {
					println("TODO: Figure out < of type " + toString(argtype));
					nacc;
				}
			} else if (name == "greater_equal") {
				argtype = dsl2WasmValType(waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, dsl2WaseInstruction);
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32Ge_s())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64Ge_s())
				else if (argtype == WasmF32Type()) arrayPush(nacc, WasmF32Ge())
				else if (argtype == WasmF64Type()) arrayPush(nacc, WasmF64Ge())
				else {
					println("TODO: Figure out >= of type " + toString(argtype));
					nacc;
				}
			} else if (name == "greater") {
				argtype = dsl2WasmValType(waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, dsl2WaseInstruction);
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32Gt_s())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64Gt_s())
				else if (argtype == WasmF32Type()) arrayPush(nacc, WasmF32Lt())
				else if (argtype == WasmF64Type()) arrayPush(nacc, WasmF64Lt())
				else {
					println("TODO: Figure out < of type " + toString(argtype));
					nacc;
				}
			} else if (name == "and") {
				argtype = dsl2WasmValType(waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, dsl2WaseInstruction);
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32And())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64And())
				else {
					println("TODO: Figure out & of type " + toString(argtype));
					nacc;
				}
			} else if (name == "or") {
				argtype = dsl2WasmValType(waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, dsl2WaseInstruction);
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32Or())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64Or())
				else {
					println("TODO: Figure out | of type " + toString(argtype));
					nacc;
				}
			} else if (name == "xor") {
				argtype = dsl2WasmValType(waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, dsl2WaseInstruction);
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32Xor())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64Xor())
				else {
					println("TODO: Figure out xor of type " + toString(argtype));
					nacc;
				}

			} else if (name == "ifelse") {
				blocktype = dsl2WasmBlockType(args[3]);
				nacc = dsl2WaseInstruction(acc, args[0]);

				thens = dsl2WaseInstruction([], args[1]);
				elses = dsl2WaseInstruction([], args[2]);

				arrayPush(nacc, WaseIfElse(blocktype, thens, elses));

			} else if (name == "return") {
				rettype = waseType(args[0]);
				argtype = dsl2WasmBlockType(rettype);

				// TODO: Check that our top-level function return type matches argtype
				println("TODO: Check that the hosting function has " + prettyDsl(rettype) + " as the return type");

				nacc = dsl2WaseInstruction(acc, args[0]);
				arrayPush(nacc, WasmReturn());

			} else {
				todo();
				nacc = fold(args, acc, dsl2WaseInstruction);
				nacc;
			}
		}
	}
}

waseType(d : DslAst) -> DslAst {
	switch (d) {
		DslNode(__, args, __): {
			lastElement(args, d);
		}
		default: d;
	}
}

dsl2WasmValType(d : DslAst) -> WasmValType {
	todo = \ -> {
		println("TODO: Compile " + prettyDsl(d) + " to wasm val type");
		WasmI32Type();
	}
	switch (d) {
		DslString(type): {
			if (type == "i32") WasmI32Type()
			else if (type == "i64") WasmI64Type()
			else if (type == "f32") WasmF32Type()
			else if (type == "f64") WasmF64Type()
			else if (type == "v128") WasmVecType()
			else if (type == "func") WasmFuncRef()
			else if (type == "extern") WasmExternRef()
			else {
				todo();
			}
		}
		DslNode(name, args, __): {
			if (name == "type") {
				dsl2WasmValType(args[1])
			} else {
				todo();
			}
		}
		default: todo();
	}
}

dsl2WasmBlockType(d : DslAst) -> WasmBlockType {
	todo = \ -> {
		println("TODO: Compile " + toString(d) + " to wasm block type");
		WasmI32Type();
	}
	switch (d) {
		DslString(type): {
			if (type == "i32") WasmI32Type()
			else if (type == "i64") WasmI64Type()
			else if (type == "f32") WasmF32Type()
			else if (type == "f64") WasmF64Type()
			else if (type == "v128") WasmVecType()
			else if (type == "func") WasmFuncRef()
			else if (type == "extern") WasmExternRef()
			else {
				todo();
			}
		}
		DslList(l): {
			if (isEmptyList(l)) {
				WasmEmptyType()
			} else todo();
		}
		default: todo();
	}
}

/*
		type = "(" ws types ")" ws "->" ws type $"fntype_2"
			| id "<" ws types ">" ws $"partype_2"

*/


isNumericWaseType(d : DslAst) -> bool {
	contains([DslString("i32"), DslString("i64"), DslString("f32"), DslString("f64")], d)
}
