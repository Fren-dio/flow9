import tools/dsl/wase/parse;
import tools/dsl/wase/type;
import tools/dsl/preprocessor/dsl_register;

// Test that evaluation of this testcase gives the expected program
testWase(testname : string, testcase : string, expected : string) -> void {
	program = cleanDsl(parseWase(testname, testcase));

	typed = typeWase(program);

	wase = dsl2wase(typed);

	got = prettyDsl(program);
	if (expected != got) {
		println(testname + " FAILED. Expected: ");
		println(expected);
		println("Got after eval:");
		println(got);
		println("As wase:");
		println(wase);
		println("Typed:");
		println(typed);
	}
}

// Cleans up excessive brace nodes
cleanDsl(e : DslAst) -> DslAst {
	switch (e) {
		DslBool(value): e;
		DslInt(value): e;
		DslDouble(value): e;
		DslString(value): e;
		DslList(value): DslList(mapList(value, cleanDsl));
		DslNode(name, args, pos): {
			if (name == "brace") {
				bargs = list2array(getDslList(args[0]));
				if (length(bargs) == 1) {
					cleanDsl(bargs[0]);
				} else {
					DslNode(name, map(args, cleanDsl), pos);
				}
			} else if (name == "int" || name == "double" || name == "string") {
				args[0];
			} else {
				DslNode(name, map(args, cleanDsl), pos);
			}
		}
	}
}

main() {
	registerDslPreprocessed();

	// Shows that recursion of dynamic code does not work well at compile time
	testWase("wase 1",
		<< 
			export foo : mutable i32 = 42;

			bar(a : f64, n : i32) -> (i32, i64) {
				n + 1;
			}
			// table calls : (i32) -> i32 = [1, 2];
//			calls : table<(i32) -> i32> = [1, 2];
		>>,
		<< >>
	);

	quit(0);
}
