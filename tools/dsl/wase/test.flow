import tools/dsl/wase/parse;
import tools/dsl/wase/type;
import tools/dsl/wase/compile;
import tools/dsl/wase/pretty_wase;
import formats/wasm/wasm_encode;

// Test that evaluation of this testcase gives the expected program
compileWase2File(filename : string, testcase : string, onDone : () -> void) -> void {
	program = parseWase(filename, testcase);

	typed = typeWase(program);
	println("Compiling " + filename);
	wase = dsl2wase(typed);

	got = prettyDsl(program);
	if (true) {
		// println("Typed:");
		// println(prettyDsl(typed));
		println("\nAs wase:");
		println(prettyWase(wase));
	}

	wasm = wase2wasm(wase);
	println(wasm);
	bytes = wasmModule2bytes(wasm);
	
	setFileContentBytes(filename + ".wasm", 
		fold(bytes, "", \acc, byte -> {
			acc + fromCharCode(byte)
		})
	);

	startProcess("wasm2wat", [filename + ".wasm", 
		//"--no-check", 
		//"--enable-all", 
		"-o", filename + ".wat"], ".", "", \ec, so, se -> {
		println(ec);
		println(so);
		println(se);
		onDone();
	});
}

main() {
	wasiTest = <<
		export memory 1;
		data "Hello, world!" offset 32;
		// wasi_snapshot_preview1!fd_write(file_descriptor, *iovs, iovs_len, nwritten) -> status_code
		import fd_write : (i32, i32, i32, i32) -> i32 = wasi_snapshot_preview1.fd_write;

		export "_start" start() -> () {
			// What offset to write from
			store<>(4, 32);
			// How many bytes to write
			store<>(8, 13);

			fd_write(1, 4, 1, 20);
			{}
		}
	>>;

	instructionTest = << 
		foo() -> i32 {
			1;
		}

		memory 1;

		export "_start" start() -> () {
			-3.1;

			ref = ref.func<foo>();

			a = clz<>(2);
			b = ctz<>(23);
			c = popcnt<>(23);

			f1 : i32 = shl<>(32, 1);
			f2 : i32 = shr_s<>(32, 1);
			f3 : i32 = shr_u<>(32, 1);
			f4 : i32 = rotl<>(32, 1);
			f5 : i32 = rotr<>(32, 1);
			f6 : i32 = eqz<>(32);
			f7 : i32 = div_u<>(32, 2);
			f8 : i32 = rem_u<>(32, 2);

			e1 : i64 = load<>(0);
			e2 : i64 = load<>(8);

			g1 : i64 = shl<>(e1, e1);
			g2 : i64 = shr_s<>(e1, e1);
			g3 : i64 = shr_u<>(e1, e1);
			g4 : i64 = rotl<>(e1, e1);
			g5 : i64 = rotr<>(e1, e1);
			g6 : i32 = eqz<>(e1);
			g7 : i64 = div_u<>(e1, e2);
			g8 : i64 = rem_u<>(e1, e2);

			h1 : f32 = load<>(0);
			h2 = abs<>(h1);
			h3 = ceil<>(h1);
			h4 = floor<>(h1);
			h5 = trunc<>(h1);
			h6 = nearest<>(h1);
			h7 = sqrt<>(h1);
			h8 = min<>(h1, h2);
			h9 = max<>(h1, h2);
			h10 = copysign<>(h1, h2);

			k1 : f64 = load<>(0);
			k2 = abs<>(k1);
			k3 = ceil<>(k1);
			k4 = floor<>(k1);
			k5 = trunc<>(k1);
			k6 = nearest<>(k1);
			k7 = sqrt<>(k1);
			k8 = min<>(k1, k2);
			k9 = max<>(k1, k2);
			k10 = copysign<>(k1, k2);

			i1 = lt_u<>(1, 2);
			i2 = gt_u<>(1, 2);
			i3 = le_u<>(1, 2);
			i4 = ge_u<>(1, 2);

			j1 = lt_u<>(e1, e2);
			j2 = gt_u<>(e1, e2);
			j3 = le_u<>(e1, e2);
			j4 = ge_u<>(e1, e2);
			{}
		}
	>>;

	memoryTest = <<
		memory 1;
		main() -> () {
			size = memory.size<>();
			previous = memory.grow<>(1);
			// Fill 128 bytes from 0 with 42
			memory.fill<>(128, 42, 0);
			// Copy 128 bytes from 0 to address 256
			memory.copy<>(128, 0, 256);

			// Special loads
			d0 : i32 = load<>(0);
			d1 : i32 = load8_s<>(0);
			d2 : i32 = load8_u<>(0);
			d3 : i32 = load16_s<>(0);
			d4 : i32 = load16_u<>(0);

			e0 : i64 = load<>(0);
			e1 : i64 = load8_s<>(0);
			e2 : i64 = load8_u<>(0);
			e3 : i64 = load16_s<>(0);
			e4 : i64 = load16_u<>(0);
			e5 : i64 = load32_s<>(0);
			e6 : i64 = load32_u<>(0);

			store<>(0, 32);
			store8<>(0, 32);
			store16<>(0, 32);

			store<>(0, e1);
			store8<>(0, e1);
			store16<>(0, e1);
			store32<>(0, e1);
		}
	>>;

	tableTest = <<
		memory 1;
		import myfuncs : table<func>(1) = module.mytable;
		import myfuncs2 : table<func>(1) = module.mytable2;
		import myexterns : table<extern>(5 10) = module.myexterns;

		main() -> () {
			fn1 = table.get<myfuncs>(0);
			fn2 = table.get<myfuncs>(1);
			extern = table.get<myexterns>(5);
			size = table.size<myfuncs>();
			was = table.grow<myfuncs2>(fn1, 2);
			table.set<myfuncs2>(2, fn2);
			table.copy<myfuncs, myfuncs2>(2, 0, 0);
			table.fill<myfuncs2>(4, fn1, 0);
			{}
		}
	>>;

	compileWase2File("wase1",
		if (false) wasiTest
		else if (true) instructionTest
		else if (true) memoryTest
		else if (true) tableTest
		else <<
			foo()-> i32 {
				 1;
			}
			export "_start" start() -> () {
				a = 1;
				1 + (a ::= 2);
				{}
			}
		>>
		,
		\ -> {
			quit(0);
		}
	);
}
