import tools/dsl/wase/parse;
import tools/dsl/wase/type;
import tools/dsl/wase/compile;
import tools/dsl/wase/pretty_wase;
import formats/wasm/wasm_encode;

// Test that evaluation of this testcase gives the expected program
compileWase2File(filename : string, testcase : string, onDone : () -> void) -> void {
	program = parseWase(filename, testcase);

	typed = typeWase(program);
	println("Compiling " + filename);
	wase = dsl2wase(typed);

	got = prettyDsl(program);
	if (true) {
		// println("Typed:");
		// println(prettyDsl(typed));
		println("\nAs wase:");
		println(prettyWase(wase));
	}

	wasm = wase2wasm(wase);
	println(wasm);
	bytes = wasmModule2bytes(wasm);
	
	setFileContentBytes(filename + ".wasm", 
		fold(bytes, "", \acc, byte -> {
			acc + fromCharCode(byte)
		})
	);

	startProcess("wasm2wat", [filename + ".wasm", 
		// "--no-check", 
		//"--enable-all", 
		"-o", filename + ".wat"], ".", "", \ec, so, se -> {
		println(ec);
		println(so);
		println(se);
		onDone();
	});
}

main() {
	test = << 
			export memory 1;
			data "Hello, world!" offset 32;
			
			// wasi_snapshot_preview1!fd_write(file_descriptor, *iovs, iovs_len, nwritten) -> status_code
			import fd_write : (i32, i32, i32, i32) -> i32 = wasi_snapshot_preview1.fd_write;

			foo() -> i32 {
				1;
			}

			export "_start" start() -> () {
				// What offset to write from
				store<>(4, 32);
				// How many bytes to write
				store<>(8, 13);

				-3.1;

				ref = ref.func<foo>();

				fd_write(1, 4, 1, 20);

				a = clz<>(2);
				b = ctz<>(23);
				c = popcnt<>(23);

				// Special loads
				d1 : i32 = load8_s<>(0);
				d2 : i32 = load8_u<>(0);
				d3 : i32 = load16_s<>(0);
				d4 : i32 = load16_u<>(0);

				e1 : i64 = load8_s<>(0);
				e2 : i64 = load8_u<>(0);
				e3 : i64 = load16_s<>(0);
				e4 : i64 = load16_u<>(0);
				e5 : i64 = load32_s<>(0);
				e6 : i64 = load32_u<>(0);

				store8<>(0, 32);
				store16<>(0, 32);

				store8<>(0, e1);
				store16<>(0, e1);
				store32<>(0, e1);

				f1 : i32 = shl<>(32, 1);
				f2 : i32 = shr_s<>(32, 1);
				f3 : i32 = shr_u<>(32, 1);
				f4 : i32 = rotl<>(32, 1);
				f5 : i32 = rotr<>(32, 1);
				f6 : i32 = eqz<>(32);

				g1 : i64 = shl<>(e1, e1);
				g2 : i64 = shr_s<>(e1, e1);
				g3 : i64 = shr_u<>(e1, e1);
				g4 : i64 = rotl<>(e1, e1);
				g5 : i64 = rotr<>(e1, e1);
				g6 : i32 = eqz<>(e1);

				h1 : f32 = load<>(0);
				h2 = abs<>(h1);
				h3 = ceil<>(h1);
				h4 = floor<>(h1);
				h5 = trunc<>(h1);
				h6 = nearest<>(h1);
				h7 = sqrt<>(h1);
				h8 = min<>(h1, h2);
				h9 = max<>(h1, h2);
				h10 = copysign<>(h1, h2);

				k1 : f64 = load<>(0);
				k2 = abs<>(k1);
				k3 = ceil<>(k1);
				k4 = floor<>(k1);
				k5 = trunc<>(k1);
				k6 = nearest<>(k1);
				k7 = sqrt<>(k1);
				k8 = min<>(k1, k2);
				k9 = max<>(k1, k2);
				k10 = copysign<>(k1, k2);

				i1 = lt_u<>(1, 2);
				i2 = gt_u<>(1, 2);
				i3 = le_u<>(1, 2);
				i4 = ge_u<>(1, 2);

				j1 = lt_u<>(e1, e2);
				j2 = gt_u<>(e1, e2);
				j3 = le_u<>(e1, e2);
				j4 = ge_u<>(e1, e2);
				{}
			}
		>>;

	memoryTest = <<
		memory 1;
		main() -> () {
			size = memory.size<>();
			previous = memory.grow<>(1);
			// Fill 128 bytes from 0 with 42
			memory.fill<>(128, 42, 0);
			// Copy 128 bytes from 0 to address 256
			memory.copy<>(128, 0, 256)
		}
	>>

	compileWase2File("wase1",
		if (false) test
		else if (true) memoryTest
		else <<
			foo()-> i32 {
				 1;
			}
			export "_start" start() -> () {
				myref = ref.func<foo>();
				[1,drop<>()];
				{}
			}
		>>
		,
		\ -> {
			quit(0);
		}
	);
}
