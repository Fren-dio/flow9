import tools/dsl/wase/parse;
import tools/dsl/wase/type;
import tools/dsl/wase/compile;
import tools/dsl/wase/pretty_wase;
import formats/wasm/wasm_encode;

// Test that evaluation of this testcase gives the expected program
compileWase2File(filename : string, testcase : string, onDone : () -> void) -> void {
	program = parseWase(filename, testcase);

	typed = typeWase(program);
	println("Compiling " + filename);
	wase = dsl2wase(typed);

	got = prettyDsl(program);
	if (true) {
		// println("Typed:");
		// println(prettyDsl(typed));
		println("\nAs wase:");
		println(prettyWase(wase));
	}

	wasm = wase2wasm(wase);
	println(wasm);
	bytes = wasmModule2bytes(wasm);
	
	setFileContentBytes(filename + ".wasm", 
		fold(bytes, "", \acc, byte -> {
			acc + fromCharCode(byte)
		})
	);

	startProcess("wasm2wat", [filename + ".wasm", "-o", filename + ".wat"], ".", "", \ec, so, se -> {
		println(ec);
		println(so);
		println(se);
		onDone();
	});
}

main() {
	compileWase2File("wase1",
		<< 
			export memory 1;
			data "Hello, world!" offset 32;
			
			// wasi_snapshot_preview1!fd_write(file_descriptor, *iovs, iovs_len, nwritten) -> status_code
			import fd_write : (i32, i32, i32, i32) -> i32 = wasi_snapshot_preview1.fd_write;

			export "_start" start() -> () {
				// What offset to write from
				store<>(4, 32);
				// How many bytes to write
				store<>(8, 13);

				-3.1;

				fd_write(1, 4, 1, 20);

				a = clz<>(2);
				b = ctz<>(23);
				c = popcnt<>(23);

				// Special loads
				d1 : i32 = load8_s<>(0);
				d2 : i32 = load8_u<>(0);
				d3 : i32 = load16_s<>(0);
				d4 : i32 = load16_u<>(0);

				e1 : i64 = load8_s<>(0);
				e2 : i64 = load8_u<>(0);
				e3 : i64 = load16_s<>(0);
				e4 : i64 = load16_u<>(0);
				e5 : i64 = load32_s<>(0);
				e6 : i64 = load32_u<>(0);

				{}
			}

		>>,
		\ -> {
			quit(0);
		}
	);
}
