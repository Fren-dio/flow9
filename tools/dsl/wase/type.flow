import tools/dsl/dsl_typing;

export {
	typeWase(ast : DslAst) -> DslAst;
}

typeWase(ast : DslAst) -> DslAst {
	dslTypeInfer(ast, mergeWaseTypes, typecheckWase);
}

mergeWaseTypes(acc : DslTypeAcc, left : DslAst, right : DslAst) -> DslAst {
	if (left == right) left
	else {
		println("TODO: Merge these types " + toString(left) + " and " + toString(right));
		left;
	}
}

typecheckWase(acc : DslTypeAcc, node : DslAst, getChildType : (int) -> DslAst) -> DslAst {
	// println(summarizeDsl(node));
	switch (node) {
		DslBool(__): DslString("i32");
		DslInt(__): DslString("i32");
		DslDouble(__): DslString("f64");
		DslString(__): DslNode("array", [DslString("i16")], 0);
		DslList(value): {
			DslList(mapiList(value, \i, __ -> getChildType(i)));
		}
		DslNode(name, args, pos): {
			if (name == "type") {
				if (getDslString(args[0]) == "auto") {
					DslInt(0)
				} else {
					args[0];
				}
			} else if (name == "fntype") {
				fargtypes = getChildType(0);
				rettypes = getChildType(1);

				DslNode("func", [fargtypes, rettypes], 0);
			} else if (name == "global") {
				// (id, export : bool, type, mutable : bool, exp, body)
				gname = getDslString(args[0]);
				type = getChildType(2);
				isMutable = getDslBool(args[3]);
				// TODO: Record if it is mutable

				acc.env := setTree(^(acc.env), gname, type);

				etype = getChildType(4);
				acc.unifyTypes(acc, type, etype);

				getChildType(5);
			} else if (name == "function") {
				// function(id, export : bool, args : [idtype(id, type)], returnType, body, scope)
				fname = getDslString(args[0]);

				fargtypes = getChildType(2);
				rettypes = getChildType(3);

				fntype = DslNode("func", [fargtypes, rettypes], 0);
				acc.env := setTree(^(acc.env), fname, fntype);

				// OK, define the types of the arguments in the scope
				fargs = list2array(getDslList(args[2]));
				fargnames = map(fargs, \fa -> {
					idtype = getDslNode(fa);
					getDslString(idtype.args[0]);
				});
				prevTypes : [Maybe<DslAst>] = mapi(list2array(getDslList(fargtypes)), \i, fargtype : DslAst -> {
					id = fargnames[i];
					etype = lookupTree(^(acc.env), id);
					acc.env := setTree(^(acc.env), id, fargtype);
					etype;
				});

				// Check the type of the body
				bodyType = getChildType(4);
				acc.unifyTypes(acc, rettypes, bodyType);

				// And unroll the existing types
				iteri(prevTypes, \i, mpt -> {
					mpt ?? {
						acc.env := setTree(^(acc.env), fargnames[i], mpt)
					} : {
						acc.env := removeFromTree(^(acc.env), fargnames[i]);
					}
				});

				getChildType(5);
			} else if (name == "idtype") {
				// Used in functions. The type is the second child
				getChildType(1)

			} else if (name == "import_fun") {
				// id type module name scope
				fname = getDslString(args[0]);
				fntype = getChildType(1);

				// OK, record the import type
				acc.env := setTree(^(acc.env), fname, fntype);
				getChildType(4);

			} else if (name == "import_global") {
				// id type mutable module name scope
				gname = getDslString(args[0]);
				type = getChildType(1);

				// TODO: Record that this id is mutable

				// OK, record the import type
				acc.env := setTree(^(acc.env), gname, type);

				getChildType(5);

			} else if (name == "memory") {
				// opt, min, max, scope
				getChildType(0);
				getChildType(1);
				getChildType(2);
				getChildType(3);
			} else if (name == "data") {
				getChildType(0);
				getChildType(1);
				getChildType(2);

			} else if (name == "empty") {
				DslList(makeList());

			// OK, expression typing

			} else if (name == "int") {
				DslString("i32");
			} else if (name == "double") {
				DslString("f64");

			} else if (name == "let") {
				// (id, type, exp, body)
				vname = getDslString(args[0]);
				type = getChildType(1);

				acc.env := setTree(^(acc.env), vname, type);

				etype = getChildType(2);
				acc.unifyTypes(acc, type, etype);

				getChildType(3);

			} else if (name == "var") {
				vname = getDslString(args[0]);
				mtype = lookupTree(^(acc.env), vname);
				mtype ?? {
					mtype
				} : {
					acc.onError(node, "Unknown var " + vname + " when type checking");
					DslInt(0);
				}

			} else if (name == "set") {
				vname = getDslString(args[0]);
				mtype = lookupTree(^(acc.env), vname);
				valtype = getChildType(1);
				mtype ?? {
					acc.unifyTypes(acc, mtype, valtype);
					DslList(makeList());
				} : {
					acc.onError(node, "Unknown var " + vname + " when type checking");
					DslInt(0);
				}

			} else if (name == "wasm_op") {
				// id, parameters, args
				op = getDslString(args[0]);
				pars = getDslList(args[1]);
				
				getChildType(1);
				opargs = getChildType(2);

				i32 = DslString("i32");
				infer = \ -> makeDslTypeVar(acc);
				list0 = DslList(makeList());
				list1 = \t1 -> DslList(makeList1(t1));
				list2 = \t1, t2 -> DslList(Cons(t2, makeList1(t1)));
				list3 = \t1, t2, t3 -> DslList(Cons(t3, Cons(t2, makeList1(t1))));
				if (op == "store") {
					acc.unifyTypes(acc, opargs, list2(i32, infer()));
					list0;
				} else if (op == "load") {
					acc.unifyTypes(acc, opargs, list1(i32));
					// We will have to infer the return type
					DslInt(0);
				} else if (op == "unreachable" || op == "nop") {
					acc.unifyTypes(acc, opargs, list0);
					list0;
				} else if (op == "break_if") {
					acc.unifyTypes(acc, opargs, list1(i32));
					list0;
				} else if (op == "drop") {
					acc.unifyTypes(acc, opargs, list0);
					list0;
				} else if (op == "select") {
					resType = infer();
					acc.unifyTypes(acc, opargs, list3(i32, resType, resType));
					resType;
				
				} else {
					println("TODO: What is the type of  '" + op  + "' " + toString(pars) + " : " + prettyDsl(opargs));
					DslList(makeList());
				}

			} else if (name == "and" || name == "or" || name == "xor") {
				left = getChildType(0);
				right = getChildType(1);
				acc.unifyTypes(acc, left, right);
				left
			} else if (name == "add" || name == "sub" || name == "mul" 
					|| name == "divu" || name == "div" || name == "mod" || name == "modu") {
				left = getChildType(0);
				right = getChildType(1);
				acc.unifyTypes(acc, left, right);
				left;
			} else if (name == "equal" || name == "not_equal" || name == "less_equal" || name == "less"
				|| name == "greater_equal" || name == "greater") {
				left = getChildType(0);
				right = getChildType(1);
				acc.unifyTypes(acc, left, right);
				DslString("i32");
			} else if (name == "is_null") {
				val = getChildType(0);
				println("TODO: Check that " + prettyDsl(val) + " is a func or extern type for is null");
				
				DslString("i32");

			} else if (name == "call") {
				fntype = getChildType(0);
				argtype = getChildType(1);
				
				retType = makeDslTypeVar(acc);
				callType = DslNode("func", [argtype, retType], 0);
				acc.unifyTypes(acc, fntype, callType);
				retType;
			} else if (name == "return" || name == "break") {
				ignore = getChildType(0);
				// TODO: In a case like if (a) return else 2;
				// arguably, the type is somehow irrelevant
				DslList(makeList());

			} else if (name == "brace" || name == "block" || name == "loop") {
				ctype = getChildType(0);
				ltype = getDslList(ctype);
				// It is the final element that is the type
				foldList(ltype, DslList(makeList()), \__, t -> t);

			} else if (name == "ifelse") {
				cond = getChildType(0);
				acc.unifyTypes(acc, cond, DslString("i32"));
				thenType = getChildType(1);
				elseType = getChildType(2);
				acc.unifyTypes(acc, thenType, elseType);
				thenType;
			} else if (name == "if") {
				cond = getChildType(0);
				acc.unifyTypes(acc, cond, DslString("i32"));
				thenType = getChildType(1);
				acc.unifyTypes(acc, thenType, DslList(makeList()));
				thenType;

			} else {
				acc.onError(node, "TODO: Type check " + prettyDsl(node));
				// This signifies a tyvar
				DslInt(0);
			}
		}
	}
}
