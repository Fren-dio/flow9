import string;
import tools/flowc/backends/wise/flow_wise_types;

// TODO: think about
// makeWiArrayConstruction()
// create runtime fns : createArrayI32_N - where n = array_length
// -> we'll replace arr = {tmp=; ...  tmp} with arr = createArrayI32_N(1,2,3);

export {
	makeStringType() -> FlowWiType; // string = array of chars

	makeWiArrayIndex(e1 : FlowWiExp, e2 : FlowWiExp) -> FlowWiExp;
	makeWiArrayConstruction(exps : [FlowWiExp], tmpIndex : int, type : FlowWiType) -> Maybe<FlowWiExp>;
	isWiArrayConstruction(exp : FlowWiExp) -> bool;
}

makeStringType() -> FlowWiType {
	FlowWiBasictype("string");
}

// TODO: type
makeWiArrayIndex(e1 : FlowWiExp, e2 : FlowWiExp) -> FlowWiExp {
	FlowWiCall(FlowWiVar("getValueArrayI32"), [e1, e2]);
}

makeWiArrayConstruction(exps : [FlowWiExp], tmpIndex : int, type : FlowWiType) -> Maybe<FlowWiExp> {
	makeDef = \ -> {
		println("array of " + toString(type) + " is not implemented");
		None();
	}
	if (exps == []) {
		Some(makeCreateArrayCall(0));
	} else {
		switch (type : FlowWiType) {
			FlowWiBasictype(t) : {
				if (t == "string") {
					makeWiArrayConstructionByType(
						exps,
						"setCharString",
						tmpIndex,
						\e -> switch (e : FlowWiExp) {
							FlowWiInt(__): Some(e);
							default : None();
						}
					);
				} else {
					makeDef();
				}
			}
			FlowWiFntype(__, __) : makeDef();
			FlowWiTupletype(__) : makeDef();
			FlowWiArrayType(t) : {
				if (t == FlowWiBasictype("i32")) {
					makeWiArrayConstructionByType(
						exps,
						"setValueArrayI32",
						tmpIndex,
						\e -> switch (e : FlowWiExp) {
							FlowWiInt(__): Some(e);
							default : None();
						}
					);
				} else {
					makeDef();
				}
			}
		}
	} 
}

makeWiArrayConstructionByType(exps : [FlowWiExp], setValFn : string, tmpIndex : int, getVal : (FlowWiExp) -> Maybe<FlowWiExp>) -> Maybe<FlowWiExp> {
	values = filtermap(exps, getVal);
	if (length(values) == length(exps)) {
		tmpVar = "tmp" + i2s(tmpIndex);
		Some(FlowWiBrace([
			FlowWiInt(0), // not to erase '{}' in the result string // TODO: fix it
			FlowWiBrace([FlowWiLet(
				tmpVar,
				0,
				FlowWiBasictype("auto"),
				makeCreateArrayCall(length(values)),
				FlowWiBrace(arrayPush(
					mapi(values, \i, value -> FlowWiCall(FlowWiVar(setValFn), [FlowWiVar(tmpVar), FlowWiInt(i), value])),
					FlowWiVar(tmpVar)
				)),
			)])
		]));
	} else {
		None();
	}
}

makeCreateArrayCall(len : int) -> FlowWiCall {
	FlowWiCall(FlowWiVar("createArrayI32"), [FlowWiInt(len)]);
}

isWiArrayConstruction(exp : FlowWiExp) -> bool {
	isCreateFn = \e -> {
		switch (e : FlowWiExp) {
			FlowWiCall(v, __) : v == makeCreateArrayCall(0).exp;
			default : false;
		}
	}
	isCreateFn(exp)
	|| {
		switch (exp : FlowWiExp) {
			FlowWiBrace(es): length(es) > 1
							&& switch (es[1] : FlowWiExp) {
								FlowWiBrace(es1): es1 != []
													&& switch (es1[0] : FlowWiExp) {
														FlowWiLet(__, __, __, e, __) : isCreateFn(e);
														default : false;
													};
								default : false;
							};
			default : false;
		}
	}

}
