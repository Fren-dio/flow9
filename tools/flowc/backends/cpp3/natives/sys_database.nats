[

Cpp3Native("connectDb", false,
"Native* $F_1(connectDb)(String* host, Int port, String* socket, String* user, String* pwd, String* databse);\n",
"Native* $F_1(connectDb)(String* host, Int port, String* socket, String* user, String* pwd, String* databse) {
	if (socket->size() == 0) {
		daotk::mysql::connection* conn = new daotk::mysql::connection(
			host->toStd(),
			user->toStd(),
			pwd->toStd(),
			database->toStd(),
			0, // timeout
			false, // reconnect
			\"\", // init command
			\"\", // charset
			port
		);
		decRc(host);
		decRc(socket);
		decRc(user);
		decRc(pwd);
		decRc(database);
		return Native::make(conn, [conn]() { delete my; });
	} else {
		fail(\"Connection to UNIX socket is not implemented yet\");
		return Native::make(0, []() { });
	}
}\n\n",
"", [], ["mysql"]),

Cpp3Native("closeDb", false,
"Void $F_1(closeDb)(Native* databse);\n",
"Void $F_1(closeDb)(Native* databse) {
	database->get<daotk::mysql::connection*>()->close();
	decRc(database);
	return void_value;
}\n\n",
"", [], ["mysql"]),

Cpp3Native("connectExceptionDb", false,
"String* $F_1(connectExceptionDb)(Native* databse);\n",
"String* $F_1(connectExceptionDb)(Native* databse) {
	return String::make(\"connectExceptionDb is not implemented\");
}\n\n",
"", [], ["mysql"]),

Cpp3Native("hasNextResultDb", false,
"Bool $F_1(hasNextResultDb)(Native* result);\n",
"Bool $F_1(hasNextResultDb)(Native* result) {
	fail(\"hasNextResultDb is not implemented\");
	return false;
}\n\n",
"", [], ["mysql"]),

Cpp3Native("nextResultDb", false,
"Vec<Union*>* $F_1(nextResultDb)(Native* result);\n",
"Vec<Union*>* $F_1(nextResultDb)(Native* result) {
	fail(\"nextResultDb is not implemented\");
	return Vec<Union*>::make();
}\n\n",
"", [], ["mysql"]),

Cpp3Native("requestDb", false,
"Native* $F_1(requestDb)(Native* database, String* query);\n",
"Native* $F_1(requestDb)(Native* database, String* query) {
	fail(\"requestDb is not implemented\");
	return nullptr;
}\n\n",
"", [], ["mysql"]),

Cpp3Native("requestExceptionDb", false,
"String* $F_1(requestExceptionDb)(Native* database);\n",
"String* $F_1(requestExceptionDb)(Native* database) {
	fail(\"requestExceptionDb is not implemented\");
	return String::make();
}\n\n",
"", [], ["mysql"]),

Cpp3Native("requestDbMulti", false,
"Vec<Vec<Vec<Union*>*>*>* $F_1(requestDbMulti)(Native* database, Vec<String*>* queries);\n",
"Vec<Vec<Vec<Union*>*>*>* $F_1(requestDbMulti)(Native* database, Vec<String*>* queries) {
	fail(\"requestDbMulti is not implemented\");
	return Vec<Vec<Vec<Union*>*>*>::make();
}\n\n",
"", [], ["mysql"]),

Cpp3Native("requestDbWithQueryParams", false,
"Native* $F_1(requestDbWithQueryParams)(Native* database, String* query, Vec<String*>* string_params);\n",
"Native* $F_1(requestDbWithQueryParams)(Native* database, String* query, Vec<String*>* string_params) {
	daotk::mysql::connection* conn = database->get<daotk::mysql::connection*>();
	std::vector<std::string> params;
	params.reserve(string_params->size());
	for (String* s : *string_params) {
		params.push_back(s->toStd());
	}
	daotk::mysql::connection::prepared_stmt* stmt = new daotk::mysql::connection::prepared_stmt(conn, query->toStd(), params);
	stmt->execute();
	return Native::make(stmt, [stmt]() { delete stmt; });
}\n\n",
"", [], ["mysql"])

]