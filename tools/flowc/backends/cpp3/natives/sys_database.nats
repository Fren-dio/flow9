[

Cpp3Native("connectDb", false,
"Native* $F_1(connectDb)(String* host, Int port, String* socket, String* user, String* pwd, String* database);\n",
"Native* $F_1(connectDb)(String* host, Int port, String* socket, String* user, String* pwd, String* database) {
	if (socket->size() == 0) {
		MysqlDbCon* db = new MysqlDbCon(host->toStd(), user->toStd(), pwd->toStd(), database->toStd(), port);
		decRc(host);
		decRc(socket);
		decRc(user);
		decRc(pwd);
		decRc(database);
		return Native::make<MysqlDbCon*>(db, [db]() { delete db; });
	} else {
		fail(\"Connection to UNIX socket is not implemented yet\");
		return Native::make(0, []() { });
	}
}\n\n",
"", [], ["mysql"]),

Cpp3Native("closeDb", false,
"Void $F_1(closeDb)(Native* nat);\n",
"Void $F_1(closeDb)(Native* db) {
	nat->get<MysqlDbCon*>()->close();
	decRc(nat);
	return void_value;
}\n\n",
"", [], ["mysql"]),

Cpp3Native("connectExceptionDb", false,
"String* $F_1(connectExceptionDb)(Native* nat);\n",
"String* $F_1(connectExceptionDb)(Native* nat) {
	String* err = String::make(nat->get<MysqlDbCon*>()->err);
	decRc(nat);
	return err;
}\n\n",
"", [], ["mysql"]),

Cpp3Native("hasNextResultDb", false,
"Bool $F_1(hasNextResultDb)(Native* nat);\n",
"Bool $F_1(hasNextResultDb)(Native* nat) {
	Bool ret = !nat->get<MysqlDbRes*>()->result.eof();
	decRc(nat);
	return ret;
}\n\n",
"", [], ["mysql"]),

Cpp3Native("nextResultDb", false,
"
Vec<Union*>* $F_1(nextResultDb)(Native* nat);
Union* makeMysqlDbField(
	const daotk::mysql::field& field,
	daotk::mysql::result& res, int i,
	const std::string& date_time_format,
	std::set<std::string>& int_overflow_fields
);
",
"
Union* makeMysqlDbField(
	const daotk::mysql::field& field,
	daotk::mysql::result& res, int i,
	const std::string& date_time_format,
	std::set<std::string>& int_overflow_fields
) {
	if (res.eof()) {
		return $F_0(DbNullField)::make<$F_0(DbNullField)*>(String::make(field.name));
	}
	switch (field.type) {
		case MYSQL_TYPE_NULL: {
			return $F_0(DbNullField)::make<$F_0(DbNullField)*>(String::make(field.name));
		}
		case MYSQL_TYPE_SHORT:
		case MYSQL_TYPE_TINY:
		case MYSQL_TYPE_INT24: {
			try {
				int val = std::stoi(res.get_field(i));
				return $F_0(DbIntField)::make<$F_0(DbIntField)*>(String::make(field.name), val);
			} catch (std::exception& e) {
				return $F_0(DbNullField)::make<$F_0(DbNullField)*>(String::make(field.name));
			}
		}
		case MYSQL_TYPE_DOUBLE:
		case MYSQL_TYPE_DECIMAL:
		case MYSQL_TYPE_FLOAT: {
			try {
				double val = std::stod(res.get_field(i));
				return $F_0(DbDoubleField)::make<$F_0(DbDoubleField)*>(
					String::make(field.name),
					std::stod(res.get_field(i))
				);
			} catch (std::exception& e) {
				return $F_0(DbNullField)::make<$F_0(DbNullField)*>(String::make(field.name));
			}
		}
		case MYSQL_TYPE_TIMESTAMP: {
			try {
				long t = std::stol(res.get_field(i));
				const std::time_put<char>& time_put = std::use_facet <std::time_put<char>>(std::locale());
				std::time_t timestamp = t / 1000.0;
				std::tm* time = std::localtime(&timestamp);
				std::ostringstream out;
				time_put.put(out, out, ' ', time, date_time_format.data(), date_time_format.data() + date_time_format.length());
				return $F_0(DbStringField)::make<$F_0(DbStringField)*>(
					String::make(field.name),
					String::make(out.str())
				);
			} catch (std::exception& e) {
				return $F_0(DbNullField)::make<$F_0(DbNullField)*>(String::make(field.name));
			}
		}
		case MYSQL_TYPE_LONG:
		case MYSQL_TYPE_LONGLONG: {
			try {
				long l_val = std::stol(res.get_field(i));
				int i_val = static_cast<int>(l_val);
				if ((long)i_val == l_val) {
					// use int type if the value fits in 32 bit integer
					return $F_0(DbIntField)::make<$F_0(DbIntField)*>(String::make(field.name), i_val);
				} else {
					int_overflow_fields.insert(field.name);
					if ((l_val & 0xFFFF000000000000L) == 0L) {
						// if the value fits in double type
						// in double 52 bits are used for the mantissa (15-16 decimal digits)
						// We support 48 bit non-negative integers as double (14 decimal digits)
						try {
							double val = std::stod(res.get_field(i));
							return $F_0(DbDoubleField)::make<$F_0(DbDoubleField)*>(String::make(field.name), val);
						} catch (std::exception& e) {
							return $F_0(DbNullField)::make<$F_0(DbNullField)*>(String::make(field.name));
						}
					} else {
						// otherwise use string
						return $F_0(DbStringField)::make<$F_0(DbStringField)*>(
							String::make(field.name),
							String::make(res.get_field(i))
						);
					}
				}
			} catch (std::exception& e) {
				return $F_0(DbNullField)::make<$F_0(DbNullField)*>(String::make(field.name));
			}
		}
		default: {
			return $F_0(DbStringField)::make<$F_0(DbStringField)*>(
				String::make(field.name),
				String::make(res.get_field(i))
			);
		}
	}
}

Vec<Union*>* $F_1(nextResultDb)(Native* nat) {
	MysqlDbRes* r = nat->get<MysqlDbRes*>();
	const std::vector<daotk::mysql::field>& fields = r->result.fields();
	Vec<Union*>* ret = Vec<Union*>::make(fields.size());
	for (Int i = 0; i < fields.size(); ++ i) {
		daotk::mysql::field field = fields.at(i);
		ret->pushBack(makeMysqlDbField(
			field, r->result, i,
			r->db()->date_time_format,
			r->db()->int_overflow_fields
		));
	}
	r->result.next();
	decRc(nat);
	return ret;
}\n\n",
"", [], ["mysql"]),

Cpp3Native("requestDb", false,
"Native* $F_1(requestDb)(Native* nat, String* query);\n",
"Native* $F_1(requestDb)(Native* nat, String* query) {
	MysqlDbRes* res = new MysqlDbRes(nat, query->toStd());
	decRc(query);
	return Native::make(res, [res]() { delete res; });
}\n\n",
"", [], ["mysql"]),

Cpp3Native("requestExceptionDb", false,
"String* $F_1(requestExceptionDb)(Native* nat);\n",
"String* $F_1(requestExceptionDb)(Native* nat) {
	String* err = String::make(nat->get<MysqlDbCon*>()->err);
	decRc(nat);
	return err;
}\n\n",
"", [], ["mysql"]),

Cpp3Native("requestDbMulti", false,
"Vec<Vec<Vec<Union*>*>*>* $F_1(requestDbMulti)(Native* nat, Vec<String*>* queries);\n",
"Vec<Vec<Vec<Union*>*>*>* $F_1(requestDbMulti)(Native* nat, Vec<String*>* queries) {
	std::string query;
	for (String* s : *queries) {
		if (query.size() > 0) {
			query += \"; \";
		}
		query += s->toStd();
	}
	decRc(queries);
	MysqlDbCon* c = nat->get<MysqlDbCon*>();
	c->con->set_server_option(MYSQL_OPTION_MULTI_STATEMENTS_ON);
	std::vector<daotk::mysql::result> results = std::move(c->con->mquery(query));
	Vec<Vec<Vec<Union*>*>*>* ret = Vec<Vec<Vec<Union*>*>*>::make(results.size());
	for (auto& res : results) {
		int num_rows = res.count();
		Vec<Vec<Union*>*>* table = Vec<Vec<Union*>*>::make(num_rows);
		const std::vector<daotk::mysql::field>& fields = res.fields();
		for (int i = 0; i < num_rows; ++ i) {
			Vec<Union*>* row = Vec<Union*>::make(fields.size());
			for (Int i = 0; i < fields.size(); ++ i) {
				daotk::mysql::field field = fields.at(i);
				row->pushBack(makeMysqlDbField(
					field, res, i,
					c->date_time_format,
					c->int_overflow_fields
				));
			}
			table->pushBack(row);
			res.next();
		}
		ret->pushBack(table);
	}
	decRc(nat);
	return ret;
}\n\n",
"", [], ["mysql"]),

Cpp3Native("requestDbWithQueryParams", false,
"Native* $F_1(requestDbWithQueryParams)(Native* database, String* query, Vec<String*>* string_params);\n",
"Native* $F_1(requestDbWithQueryParams)(Native* database, String* query, Vec<String*>* string_params) {
	/*daotk::mysql::connection* conn = database->get<daotk::mysql::connection*>();
	std::vector<std::string> params;
	params.reserve(string_params->size());
	for (String* s : *string_params) {
		params.push_back(s->toStd());
	}
	daotk::mysql::connection::prepared_stmt* stmt = new daotk::mysql::connection::prepared_stmt(conn, query->toStd(), params);
	stmt->execute();
	return Native::make(stmt, [stmt]() { delete stmt; });*/
	fail(\"requestDbWithQueryParams is not implemented yet\");
	return nullptr;
}\n\n",
"", [], ["mysql"])

]