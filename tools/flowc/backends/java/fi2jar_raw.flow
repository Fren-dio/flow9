import sys/system;
import sys/target;
import tools/flowc/backends/common;
import promise;

export {
	fi2JavaBuildRaw(cfg : FiJavaConfig, path : string, callback : (int) -> void) -> void;
}

fi2JavaBuildRaw(cfg : FiJavaConfig, path : string, callback : (int) -> void) -> void {
	jar = changeFileExt(cfg.jarfile, ".jar");
	flowdir = rtrim2(getFlowDir(), "/");
	outdir = if (cfg.outputdir == "") "." else cfg.outputdir;

	java_deps = fi2JavaJarDependencies(cfg, path);

	exit_handler = \prog, success, failure -> {
		\errcode, stdout, stderr -> {
			if (stdout != "") fcPrintln(stdout, cfg.threadId);
			if (stderr != "") fcPrintln(stderr, cfg.threadId);
			if (errcode == 0) {
				success(0)
			} else {
				fcPrintln("Failed to run " + prog + ". Check if " + prog + " is installed, JAVA_HOME environment variable is properly defined and is present in your PATH.", cfg.threadId);
				failure(5 + errcode)
			}
		}
	}
	build_program_jar = \fulfil, reject -> {
		if (cfg.verbose > 0) {
			fcPrintln("Adding a program to " + jar, cfg.threadId);
		}
		args = ["feu", jar, cfg.packageName + "." + cfg.mainClassName, "-C", cfg.generatedir, strReplace(cfg.packageName, ".", "/")];
		fcPrintln("BUILD PROGRAM(C): jar " + strGlue(args, " "), cfg.threadId);
		startProcess("jar", args, outdir, "",
			exit_handler("jar",
				\code -> {
					if (cfg.verbose > 0) {
						fcPrintln("Run with \"java -jar " + jar + "\"", cfg.threadId);
					}
					fulfil(code)
				},
				reject
			)
		)
	}
	build_runtime_jar = \fulfil, reject -> {
		if (cfg.verbose > 0) {
			fcPrintln("Adding a runtime to " + jar, cfg.threadId);
		}
		args1 = ["cf", jar, "-C", flowdir + "/platforms/java", "com/area9innovation/flow"];
		//args2 = fi2JavaJarDependencies(cfg, path);
		args = args1;
		fcPrintln("BUILD RUNTIME(B): jar " + strGlue(args, " "), cfg.threadId);
		startProcess("jar", args, outdir, "", exit_handler("jar", fulfil, reject));
	}
	compile_java = \fulfil, reject -> {
		if (cfg.verbose > 0) {
			fcPrintln("Compiling the generated code", cfg.threadId);
		}
		cp_sep = if (hasTargetName("windows")) ";" else ":";
		args = ["-Xlint:unchecked", "-encoding", "UTF-8", "-cp", 
			flowdir + "/platforms/java" + cp_sep + "javagen" + 
				fold(java_deps, "", \acc, dep -> acc + cp_sep + pathCombine(dep.first, dep.second)) +
				fold(cfg.externNatives, "", \acc, nat -> acc + cp_sep + nat)
			,
			"@" + path + "/sources"
		];
		//args2 = fi2JavaRuntimeHosts(cfg);
		//args = concat(args1, args2);
		fcPrintln("COMPILE(A): javac " + strGlue(args, " "), cfg.threadId);
		startProcess("javac", args, outdir, "", exit_handler("javac", fulfil, reject));
	}
	//fi2JavaUpdateSources(cfg, path);

	jobs = concat3(
		[Promise(compile_java), Promise(build_runtime_jar)],
		concat(
			mapConcat(java_deps, \p -> {
				dir = p.first;
				jar_lib = p.second;
				lib_name = changeFileExt(jar_lib, "");
				lib_dir = pathCombine(dir, lib_name);
				concat(
					if (isDirectory(lib_dir)) [] else {
						[
							Promise(\fulfil, reject -> {
								args = [lib_name];
								fcPrintln("\tMKDIR(A): 'mkdir " + strGlue(args, " ") + "' (dir: " + dir + ")", cfg.threadId);
								startProcess("mkdir", args, dir, "", exit_handler("mkdir", fulfil, reject))
							}),
							Promise(\fulfil, reject -> {
								args = ["-xf", pathCombine(dir, jar_lib)];
								fcPrintln("\tEXTRACT_JAR(B): 'jar " + strGlue(args, " ") + "' (dir: " + pathCombine(dir, lib_name) + ")", cfg.threadId);
								startProcess("jar", args, lib_dir, "", exit_handler("jar -xf", fulfil, reject))
							})
						]
					},
					[Promise(\fulfil, reject -> {
						args = ["fu", jar, "-C", lib_dir, "."];
						fcPrintln("\tUPDATE_JAR(C): 'jar " + strGlue(args, " ") + "' (dir: " + resolveRelativePath(outdir) + ")", cfg.threadId);
						startProcess("jar", args, outdir, "", exit_handler("jar -u", fulfil, reject))
					})]
				)
			}),
			map(cfg.externNatives, \nat -> {
				//dir = p.first;
				//jar_lib = p.second;
				//lib_name = changeFileExt(jar_lib, "");
				//lib_dir = pathCombine(dir, lib_name);
				Promise(\fulfil, reject -> {
					args = ["fu", jar, "-C", nat, "."];
					fcPrintln("\tUPDATE_JAR(D): 'jar " + strGlue(args, " ") + "' (dir: " + resolveRelativePath(outdir) + ")", cfg.threadId);
					startProcess("jar", args, outdir, "", exit_handler("jar -u", fulfil, reject))
				})
			}),
		),
		[Promise(build_program_jar)]	
	);

	doneP(
		allP(jobs),
		\codes -> if (forall(codes, \code -> code == 0)) callback(0) else callback(5),
		callback
	);
}

fi2JavaJarDependencies(cfg : FiJavaConfig, path : string) -> [Pair<string, string>] {
	jar_deps = filtermap(cfg.dependencies, \dep ->
		if (!startsWith(dep, "jar")) None() else Some(substring(dep, 4, strlen(dep) - 5))
	);
	flow_dir = getFlowDir();
	jar_deps_resolved = filtermap(jar_deps, \dep -> {
		path1 = pathCombine(path, dep);
		if (fileExists(path1)) Some(Pair(path, dep)) else {
			path2 = pathCombineMany([flow_dir, "platforms", "java", "lib"]);
			if (fileExists(pathCombine(path2, dep))) Some(Pair(path2, dep)) else {
				fcPrintln("library: " + dep + " is not resolved", cfg.threadId);
				None();
			}
		}
	});
	jar_deps_resolved;
}

fi2JavaJarNatives(cfg : FiJavaConfig) -> [string] {
	mapConcat(cfg.externNatives, \nat -> ["-C", nat, "com/area9innovation/flow"]);
}

fi2JavaUpdateSources(cfg : FiJavaConfig, path : string) -> void {
	prog_sources_path = pathCombine(path, "sources");
	prog_sources = getFileContent(prog_sources_path);
	prog_sources_set = buildSet(filter(strSplit(prog_sources, "\n"), isNotSpace));
	extern_sources = set2array(fold(cfg.externNatives, makeSet(), \acc, extern -> 
		mergeSets(acc, buildSet(
			filter(readDirectoryRecursively(extern), \file -> endsWith(file, ".java"))
		))
	));
	extra_sources = filter(extern_sources, \src -> !containsSet(prog_sources_set, src));
	if (length(extra_sources) > 0) {
		setFileContent(prog_sources_path, prog_sources + "\n" + strGlue(extra_sources, "\n"));
		{}
	}
}
