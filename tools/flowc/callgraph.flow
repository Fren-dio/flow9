import tools/flowc/manipulation/deadcode;

export {
	// Print a callgraph in format:
	//
	// *** file: algorithms.flow
	// arrayPushSortedWithLimit: length mergeArrays subrange
	// binarySearch: binarySearchInternal genericCompare length
	// binarySearch2: binarySearchInternal length
	// binarySearchEx: binarySearchInternal genericCompare
	// ....
	printCallGraph(filename : string, prog : FiProgram) -> void;
}

printCallGraph(filename : string, prog : FiProgram) -> void {
	lines = concatA(map(getTreeValues(prog.modules), \module -> {
		config = prog.config.config;
		useFullPath = isConfigParameterTrue(config, "callgraph-fullpath");

		heading = "*** file: " + (if (useFullPath) module.fileinfo.fullpath else {module.fileinfo.flowfile + ".flow"});
		functions = map(module.functions, \f : FiFunctionDec ->
			Pair(f.name, fifreevars(f.lambda))
		);
		natives = map(module.natives, \f : FiNativeDec ->
			Pair(f.name,
				switch (f.fallbackLambda) {
					FiLambda(__, __, __, __): fifreevars(f.fallbackLambda);
					FiVoid(__): makeSet();
					default: {
						fcPrintln("fallbackLambda in FiNativeDec must be FiLambda or FiVoid, but is: " + prettyFiExp(dummyPretty, f.fallbackLambda), prog.config.threadId);
						makeSet()
					}
				}
			)
		);
		lines2 = map(concat(natives, functions), \p : Pair<string, Set<string>> ->
			p.first + ": " + strGlue(set2array(p.second), " ")
		);
		concat([heading], lines2)
	}));
	if (setFileContent(filename, strGlue(map(lines, \l -> l + "\n"), ""))) {
		if (prog.config.verbose > 0) {
			fcPrintln("Callgraph was successfully written to file '" + filename + "'", prog.config.threadId);	
		}
	} else {
		fcPrintln("Cannot write callgraph to file '" + filename + "'", prog.config.threadId);
	}
}

