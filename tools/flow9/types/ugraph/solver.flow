import tools/flow9/types/ugraph/tnode;
import tools/flow9/types/ugraph/debug;

export {
	solveTNodes(tmap : TMap, visited : ref Set<int>, eclass : int) -> void;
}

solveTNodes(tmap : TMap, visited : ref Set<int>, eclass : int) -> void {
	if (eclass < ^(tmap.nextEClass)
		&& solveEClass(tmap, visited, eclass)) {
		solveTNodes(tmap, visited, eclass + 1);
	} else {}
}

solveEClass(tmap : TMap, visited : ref Set<int>, eclass : int) -> bool {
	if (!containsSet(^visited, eclass)) {
		root = rootTTypeEClass(tmap, eclass);
		if (root == eclass) {
			visited := insertSet(^visited, root);
			// OK, this is a root node. Let us try this one
			tnode = getUnionMapValue(tmap.tmap, root);
			snode = simplifyTNode(tmap, tnode, makeErrorReason([0], "Solving"));
			// OK, here try to resolve this node
			if (solveTNode(tmap, visited, eclass, snode)) {
				true;
			} else {
				false;
			}
		} else true;
	} else true;
}

solveTNode(tmap : TMap, visited : ref Set<int>, eclass : int, tnode : TNode) -> bool {
	if (isEmptyTNode(tnode)) true
	else {
		switch (tnode) {
			TNodeName(name, typars, pos): true;
			TNodeOverload(unique, overloads, pos): {
				nonflows = filter(overloads, \n -> !isFlowNode(n));
				if (length(nonflows) == 1) {
					reason = makeErrorReason([0], "Simplified away from flow");
					ecl = makeEClassForTNode(tmap, nonflows[0], reason);
					joinTNodes(tmap, eclass, ecl, reason);
					true;
				} else {
					tryTNodes(tmap, visited, eclass, overloads);
				}
			}
			TNodeSupertype(uniques, subtypes, unknownSubtypes, maxed, pos): {
				def = \ -> {
					supers = getPossibleTSupers(tmap, tnode);
					if (isEmptySet(supers)) {
						// OK, it is polymorphic or decided elsewhere
						true;
					} else {
						supernodes = map(set2array(supers), \super -> {
							instantiateTNodeName(tmap, super, subtypes, pos);
						});
						tryTNodes(tmap, visited, eclass, supernodes);
					}
				}
				if (isEmptySet(unknownSubtypes)) {
					def();
				} else {
					us = foldSet(unknownSubtypes, true, \acc, st -> {
						acc && solveEClass(tmap, visited, st)
					});
					if (us) {
						// OK, we resolved these somehow
						reason = makeErrorReason([0], "Solving after unknnown");
						snode = simplifyTNode(tmap, tnode, reason);
						if (snode != tnode) {
							ecl = makeEClassForTNode(tmap, snode, reason);
							joinTNodes(tmap, eclass, ecl, reason);
							{}
						}
						switch (snode) {
							TNodeName(__, __, __): {
								true;
							}
							TNodeOverload(__, __, __): {
								solveTNode(tmap, visited, eclass, snode);
							}
							TNodeSupertype(__, __, unknownSubtypes2, __, __): {
								if (isEmptySet(unknownSubtypes2)) {
									def();
								} else {
									if (false) {
										iterSet(unknownSubtypes2, \st -> {
											println("Could not resolve unknown " + prettyEClass(tmap, st));
										});
									}
									false;
								}
							}
						}
					} else {
						us;
					}
				};
			}
		}
	}
}

// OK, try these in turn, to find one that works
tryTNodes(tmap : TMap, visited : ref Set<int>, eclass : int, nodes : [TNode]) -> bool {
//	println("TODO: Try these " + superglue(nodes, \n -> prettyTNode(tmap, n), ",") + " for " + prettyEClass(tmap, eclass) + " (e" + i2s(eclass) + ")");
	false;
}
