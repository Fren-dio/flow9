import tools/flow9/types/cgraph/cgraph;
import tools/flow9/types/cgraph/pretty;
import tools/flow9/types/ugraph/tmap;
import tools/flow9/types/cgraph/constraint;
import tools/flow9/types/pretty;
import tools/flow9/bexp/bexp;

export {
	// At the end, we use this to resolve the eclasses
	resolveCNodes(tmap : TMap, verbose : bool) -> Tree<int, TType>;

	// Given the resolution map, and a given eclass, find the final type
	resolveCNode(tmap : TMap, eclasses : Tree<int, TType>, eclass : int) -> Maybe<BType>;
}

resolveCNodes(tmap : TMap, verbose : bool) -> Tree<int, TType> {
	if (verbose) dumpPostponed(tmap);

	// Do all subtypes that work
	repeatList(tmap.cmap.constraints, \c : TConstraint -> {
		ok = subtypeCEClass(tmap, c.subtype, c.supertype, true, c.reason);
		if (ok) {
			// OK, then do it
			ok2 = subtypeCEClass(tmap, c.subtype, c.supertype, false, c.reason);
			if (verbose && ok2) {
				println("  " + prettyCEClass(tmap.cmap, c.subtype) + " sub " + prettyCEClass(tmap.cmap, c.supertype) + " worked");
			}
			ok2;
		} else ok;
	}, 5);

	// Do all the unifications that work
	repeatList(tmap.cmap.unifications, \c : TUnification -> {
		ok = unifyCEClass(tmap, c.left, c.right, true, c.reason);
		if (ok) {
			// OK, then do it
			ok2 = unifyCEClass(tmap, c.left, c.right, false, c.reason);
			if (verbose && ok2) {
				println("  " + prettyCEClass(tmap.cmap, c.left) + " unify " + prettyCEClass(tmap.cmap, c.right) + " worked");
			}
			ok2;
		} else ok;
	}, 5);

	if (verbose) {
		println("Remaining subs become unifications");
		dumpPostponed(tmap);
	}

	// Do all subtypes that work as unification
	repeatList(tmap.cmap.constraints, \c : TConstraint -> {
		ok = unifyCEClass(tmap, c.subtype, c.supertype, true, c.reason);
		if (ok) {
			// OK, then do it
			ok2 = unifyCEClass(tmap, c.subtype, c.supertype, false, c.reason);
			if (verbose && ok2) {
				println("  " + prettyCEClass(tmap.cmap, c.subtype) + " sub " + prettyCEClass(tmap.cmap, c.supertype) + " worked as unify");
			}
			ok2;
		} else ok;
	}, 5);

	if (verbose) {
		println("At the end");
		dumpPostponed(tmap);
	}

	doResolveCNodes(tmap);
}

dumpPostponed(tmap : TMap) -> void {
	constraints = ^(tmap.cmap.constraints);
	if (!isEmptyList(constraints)) {
		println("Postponed subtypes:");
		iterList(constraints, \cc -> {
			println("  " + prettyCEClass(tmap.cmap, cc.subtype) + " sub " + prettyCEClass(tmap.cmap, cc.supertype));
		});
		println("");
	}
	unifications = ^(tmap.cmap.unifications);
	if (!isEmptyList(unifications)) {
		println("Postponed unifications:");
		iterList(unifications, \cc -> {
			println("  " + prettyCEClass(tmap.cmap, cc.left) + " vs " + prettyCEClass(tmap.cmap, cc.right));
		});
		println("");
	}

}

repeatList(rlist : ref List<?>, fn : (?) -> bool, iter : int) -> void {
	if (iter == 0) {}
	else {
		workDone = processList(rlist, fn);
		if (workDone) {
			repeatList(rlist, fn, iter - 1);
		}
	}
}

// Returns true if we did something
processList(rlist : ref List<?>, fn : (?) -> bool) -> bool {
	list = ^rlist;
	rlist := makeList();
	newList = foldList(list, makeList(), \acc, e -> {
		didWork = fn(e);
		if (didWork) {
			acc;
		} else Cons(e, acc);
	});
	rlist := concatList(newList, ^rlist);
	!isEmptyList(^rlist);
}

doResolveCNodes(tmap : TMap) -> Tree<int, TType> {
	types = ref makeTree();
	visited : ref Set<int> = ref makeSet();

	verbose = isTracingId(tmap.tracing, StageTypeInference(), 1, ^(tmap.topid));

	iterUnionMap(tmap.cmap.cmap, \root, node -> {
		if (node == CEpsilon()) {

		} else {
			if (verbose) {
				println(debugCNode(tmap, root));
			}
			mtype = resolveCNode(tmap, ^types, /*visited,*/ root);
			mtype ?? {
				// println(mtype);
			} : {
				// println("Error: Could not resolve e" + i2s(root));
			}
		}
	});
	^types;
}

resolveCNode(tmap : TMap, eclasses : Tree<int, TType>, eclass : int) -> Maybe<BType> {
	root = findUnionMapRoot(tmap.cmap.cmap, eclass);
	mtype = lookupTree(eclasses, root);
	mtype ?? {
		println("TODO: Convert " + prettyTType(mtype) + " to btype");
		None();
	} : {
		val = getUnionMapValue(tmap.cmap.cmap, root);
		switch (val) {
			CEpsilon(): {
				// println("TODO: Empty eclass " + i2s(eclass) + " as btype");
				None();
			}
			CName(name, typars, reason): {
				btypars = filtermap(typars, \tp -> {
					resolveCNode(tmap, eclasses, tp);
				});
				if (length(btypars) == length(typars)) {
					Some(BTypeName(name, btypars));
				} else {
					// println("Missing type pars for " + name);
					None();
				}
			}
			CFunction(args, return, reason): {
				bargs = filtermap(args, \arg -> {
					resolveCNode(tmap, eclasses, arg);
				});
				if (length(bargs) == length(args)) {
					mbret = resolveCNode(tmap, eclasses, return);
					mbret ?? {
						Some(BTypeFunction(bargs, mbret));
					} : {
						// println("Unknown return");
						None();
					}
				} else {
					// println("Missing args for function");
					None();
				}
			}
			COverload(unique, options, reason): {
				// We just randomly pick the smallest one
				mmin = popMinSet(options);
				mmin ?? {
					resolveCNode(tmap, eclasses, mmin.value);
				}: {
					None();
				}
			}
		}
	}
}
