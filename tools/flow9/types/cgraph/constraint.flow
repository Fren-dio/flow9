import tools/flow9/types/cgraph/cgraph;
import tools/flow9/types/cgraph/dtype;
import tools/flow9/types/cgraph/unionmap;
import tools/flow9/types/ugraph/tmap;
import tools/flow9/types/cgraph/subtype;
import tools/flow9/types/pretty;

export {
	// When we know the type, find or make an eclass for this type
	resultCType(tmap : TMap, t : TType, reason : ErrorReason) -> TTypeEClass;

	// We know the result is a unification of these types
	unifyCType(tmap : TMap, left : TType, right : TType, reason : ErrorReason) -> TTypeEClass;

	// We know we have to subtype here - TODO: Figure out what the result is?
	subtypeCType(tmap : TMap, subtype : TType, supertype : TType, reason : ErrorReason) -> void;

	// When we have a DType, we use this one. Instantiates polymorphism
	dtype2CType(tmap : TMap, d : DType, reason : ErrorReason) -> TTypeEClass;
}

resultCType(tmap : TMap, t : TType, reason : ErrorReason) -> TTypeEClass {
	TTypeEClass(findOrMakeCNodeClass(tmap, t, reason));
}

unifyCType(tmap : TMap, left : TType, right : TType, reason : ErrorReason) -> TTypeEClass {
	lclass = findOrMakeCNodeClass(tmap, left, reason);
	rclass = findOrMakeCNodeClass(tmap, right, reason);
	root = unionUnionMap(tmap.cmap.cmap, lclass, rclass, reason);
	TTypeEClass(root);
}

subtypeCType(tmap : TMap, subtype : TType, supertype : TType, reason : ErrorReason) -> void {
	subClass = findOrMakeCNodeClass(tmap, subtype, reason);
	superClass = findOrMakeCNodeClass(tmap, supertype, reason);

	// prettyCNode(tmap.cmap, sub) + " vs "  + prettyCNode(tmap.cmap, super)

	subtypeCEClass(tmap, subClass, superClass, reason);
}

subtypeCEClass(tmap : TMap, subClass : int, superClass : int, reason : ErrorReason) -> void {
	sub : CNode = getUnionMapValue(tmap.cmap.cmap, subClass);
	super : CNode = getUnionMapValue(tmap.cmap.cmap, superClass);

	if (sub == CEpsilon() && super == CEpsilon()) {
		// OK, postpone
		println("TODO: Postpone " + prettyCNode(tmap.cmap, sub) + " vs "  + prettyCNode(tmap.cmap, super));
	} else {
		todo = \ -> {
			println("TODO: Subtype " + prettyCNode(tmap.cmap, sub) + " vs "  + prettyCNode(tmap.cmap, super));
		};
		error = \ -> {
			println("TODO: Report error on subtype " + prettyCNode(tmap.cmap, sub) + " vs "  + prettyCNode(tmap.cmap, super));
		}
		switch (sub) {
			CEpsilon(): {
				// OK, we should find all subtypes of super, and make an overload for those
				overload = makeSubtypeOverload(tmap, super, reason);
				setUnionMapValue(tmap.cmap.cmap, subClass, overload);
			}
			CName(name, typars, subreason): {
				switch (super) {
					CEpsilon(): {
						overload = makeSupertypeOverload(tmap, sub, reason);
						setUnionMapValue(tmap.cmap.cmap, superClass, overload);
					}
					CName(sname, stypars, supreason): {
						if (name == sname) {
							if (length(typars) == length(stypars)) {
								iteri(typars, \i, typar -> {
									subtypeCEClass(tmap, typar, stypars[i], reason);	// TODO: Elaborate reason?
								});
							} else {
								error();
							}

						} else {
							todo();
						}
					}
					CFunction(sargs, return, supreason): todo();
					COverload(sunique, options, supreason): todo();
				}
			}
			CFunction(args, return, subreason): {
				switch (super) {
					CEpsilon(): {
						overload = makeSupertypeOverload(tmap, sub, reason);
						setUnionMapValue(tmap.cmap.cmap, superClass, overload);
					}
					CName(sname, stypars, supreason): todo();
					CFunction(sargs, sreturn, supreason): {
						if (length(args) == length(sargs)) {
							iteri(args, \i, arg -> {
								subtypeCEClass(tmap, sargs[i], arg, reason);	// TODO: Elaborate reason?
							});
							subtypeCEClass(tmap, return, sreturn, reason);	// TODO: Elaborate reason?
						} else {
							error();
						}
					}
					COverload(sunique, options, supreason): todo();
				}
			}
			COverload(unique, options, subreason): todo();
		}
	}
}

dtype2CType(tmap : TMap, d : DType, reason : ErrorReason) -> TTypeEClass {
	tt = dtype2CType2(tmap, ref makeTree(), d);
	resultCType(tmap, tt, reason);
}
