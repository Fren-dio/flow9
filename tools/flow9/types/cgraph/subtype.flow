import tools/flow9/types/cgraph/cgraph;
import tools/flow9/types/ugraph/class;
import tools/flow9/types/cgraph/pretty;
import tools/flow9/types/ugraph/tmap;

export {
	// Find all subtypes of this (super) node
	makeSubtypeOverload(tmap : TMap, node : CNode, reason : ErrorReason) -> CNode;

	// Find all supertypes of this (sub)node. Constructs new eclasses as required
	makeSupertypeOverload(tmap : TMap, node : CNode, reason : ErrorReason) -> CNode;

	// Given a subtype, construct the corresponding supertype with the right type parameters
	makeSupertypeFromSub(tmap : TMap, sub : CName, super : string) -> int;
}

makeSubtypeOverload(tmap : TMap, node : CNode, reason0 : ErrorReason) -> CNode {
	todo = \ -> {
		println("TODO: Find all sub types of " + prettyCNode(tmap.cmap, node));
		node;
	}
	switch (node) {
		CEpsilon(): todo();
		CName(name, typars, reason): {
			subs = ^(tmap.resolveSubtypes)(name);
			if (subs == []) node
			else todo();
		}
		CFunction(args, return, reason): {
			todo();
		}
		COverload(unique, options, reason): {
			todo();
		}
	}
}

makeSupertypeOverload(tmap : TMap, node : CNode, reason0 : ErrorReason) -> CNode {
	todo = \ -> {
		println("TODO: Find all super types of " + prettyCNode(tmap.cmap, node));
		node;
	}
	switch (node) {
		CEpsilon(): todo();
		CName(name, typars, reason): {
			supers = ^(tmap.resolveSupertypes)(name);
			if (supers == []) node
			else {
				nclass = makeTNodeClass(tmap);
				setUnionMapValue(tmap.cmap.cmap, nclass, node);

				supertypes = map(supers, \super -> {
					makeSupertypeFromSub(tmap, node, super);
				});
				all = buildSet(arrayPush(supertypes, nclass));
				COverload(
					makeSet1(tmap.mkUnique()),
					all,
					node.reason
				)
			}
		}
		CFunction(args, return, reason): {
			returnNode = getUnionMapValue(tmap.cmap.cmap, return);
			if (returnNode != CEpsilon()) {
				// OK, find the supertype of the return type
				superReturn : CNode = makeSupertypeOverload(tmap, returnNode, reason0);
				if (superReturn != returnNode) {
					// We overload on the returntype somehow
					nclass = makeTNodeClass(tmap);
					setUnionMapValue(tmap.cmap.cmap, nclass, superReturn);
					CFunction(args, nclass, reason);
				} else node;
			} else todo();
		}
		COverload(unique, options, reason): {
			todo();
		}
	}
}

makeSupertypeFromSub(tmap : TMap, sub : CName, super : string) -> int {
	node = if (sub.typars == []) {
		CName(super, [], sub.reason);
	} else {
		println("TODO: Build " + super + " supertype from " + prettyCNode(tmap.cmap, sub));
		CName(super, [], sub.reason);
	};

	nclass = makeTNodeClass(tmap);
	setUnionMapValue(tmap.cmap.cmap, nclass, node);
	nclass;
}
