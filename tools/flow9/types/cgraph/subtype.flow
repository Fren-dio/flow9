import tools/flow9/types/cgraph/cgraph;
import tools/flow9/types/ugraph/class;
import tools/flow9/types/cgraph/pretty;
import tools/flow9/types/ugraph/tmap;

export {
	// Find all subtypes of this (super) node
	makeSubtypeOverload(tmap : TMap, node : CNode, reason : ErrorReason) -> CNode;

	// Find all supertypes of this (sub)node. Constructs new eclasses as required
	makeSupertypeOverload(tmap : TMap, node : CNode, reason : ErrorReason) -> CNode;

	// Given a subtype, construct the corresponding supertype with the right type parameters
	makeSupertypeFromSub(tmap : TMap, sub : CName, super : string) -> int;
}

makeSubtypeOverload(tmap : TMap, node : CNode, reason0 : ErrorReason) -> CNode {
	todo = \ -> {
		println("TODO: Find all sub types of " + prettyCNode(tmap.cmap, node));
		node;
	}
	switch (node) {
		CEpsilon(): todo();
		CName(name, typars, reason): {
			subs = ^(tmap.resolveSubtypes)(name);
			if (subs == []) node
			else {
				nclass = makeTNodeClass(tmap);
				setUnionMapValue(tmap.cmap.cmap, nclass, node);

				subtypes = map(subs, \sub -> {
					makeSubtypeFromSuper(tmap, node, sub);
				});
				all = buildSet(arrayPush(subtypes, nclass));
				COverload(
					makeSet1(tmap.mkUnique()),
					all,
					node.reason
				)
			}
		}
		CFunction(args, return, reason): {
			todo();
		}
		COverload(unique, options, reason): {
			todo();
		}
	}
}

makeSupertypeOverload(tmap : TMap, node : CNode, reason0 : ErrorReason) -> CNode {
	todo = \ -> {
		println("TODO: Find all super types of " + prettyCNode(tmap.cmap, node));
		node;
	}
	switch (node) {
		CEpsilon(): todo();
		CName(name, typars, reason): {
			supers = ^(tmap.resolveSupertypes)(name);
			if (supers == []) node
			else {
				nclass = makeTNodeClass(tmap);
				setUnionMapValue(tmap.cmap.cmap, nclass, node);

				supertypes = map(supers, \super -> {
					makeSupertypeFromSub(tmap, node, super);
				});
				all = buildSet(arrayPush(supertypes, nclass));
				COverload(
					makeSet1(tmap.mkUnique()),
					all,
					node.reason
				)
			}
		}
		CFunction(args, return, reason): {
			returnNode = getUnionMapValue(tmap.cmap.cmap, return);
			if (returnNode != CEpsilon()) {
				// OK, find the supertype of the return type
				superReturn : CNode = makeSupertypeOverload(tmap, returnNode, reason0);
				if (superReturn != returnNode) {
					// We overload on the returntype somehow
					nclass = makeTNodeClass(tmap);
					setUnionMapValue(tmap.cmap.cmap, nclass, superReturn);
					CFunction(args, nclass, reason);
				} else node;
			} else todo();
		}
		COverload(unique, options, reason): {
			todo();
		}
	}
}

makeSupertypeFromSub(tmap : TMap, sub : CName, super : string) -> int {
	msuperdef = ^(tmap.resolveUnionName)(super);
	switch (msuperdef) {
		None(): {
			println("ERROR: Could not find " + super);
			node = CName(super, [], sub.reason);
			nclass = makeTNodeClass(tmap);
			setUnionMapValue(tmap.cmap.cmap, nclass, node);
			nclass;
		}
		Some(superdef): {
			node = if (superdef.typars == []) {
				CName(super, [], sub.reason);
			} else {
				println("TODO: Grab typars for " + super + " supertype from " + prettyCNode(tmap.cmap, sub));
				CName(super, 
					map(superdef.typars, \tp -> {
						makeTNodeClass(tmap)
					}),
					sub.reason
				);
			};

			nclass = makeTNodeClass(tmap);
			setUnionMapValue(tmap.cmap.cmap, nclass, node);
			nclass;
		}
	}
}

makeSubtypeFromSuper(tmap : TMap, super : CName, sub : string) -> int {
	msuperdef = ^(tmap.resolveUnionName)(super.name);
	switch (msuperdef) {
		None(): {
			println("ERROR: Could not find " + super.name);
			node = CName(sub, [], super.reason);
			nclass = makeTNodeClass(tmap);
			setUnionMapValue(tmap.cmap.cmap, nclass, node);
			nclass;
		}
		Some(superdef): {
			println("TODO: Grab typars for " + sub + " subtype from " + prettyCNode(tmap.cmap, super));
			println(superdef);
			node = CName(sub, [], super.reason);
			nclass = makeTNodeClass(tmap);
			setUnionMapValue(tmap.cmap.cmap, nclass, node);
			nclass;
		}
	}
}
