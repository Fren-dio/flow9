import tools/flow9/dexp/dexp;
import tools/flow9/dexp/pretty;
import tools/flow9/types/ugraph/tnode;
import tools/flow9/types/builtin;

export {
	// This introduces explicit casts where we have implicit ones.
	implicitCasts(tmap : TMap, global : DGlobal) -> DGlobal;
}

implicitCasts(tmap : TMap, global : DGlobal) -> DGlobal {
	DGlobal(global with value = implicitDExpCasts(tmap, global.value, global.eclass));
}

implicitDExpCasts(tmap : TMap, e : DExp, expectedEClass : int) -> DExp {
	// Adds a cast if we do not have the type that is expected
	wrap = \hasEClass : int, ee : DExp -> {
		// Check if these eclasses correspond to the same type in the eclass world:
		if (isSameEClassInTMap(tmap, expectedEClass, hasEClass)) ee
		else {
			// OK, we need a cast.
			makeImplicitCast(tmap, ee, hasEClass, expectedEClass)
		}
	}
	// The same, but with a TType as the interface
	wrapType = \type : TType, ee : DExp -> {
		eclass = findTNode(tmap, type);
		wrap(eclass, ee);
	}
	todo = \ -> {
		println("Implement implicit casts for this: " + summarizeDExp(e));
		e;
	}
	switch (e) {
		DVoid(pos): wrapType(voidTType, e);
		DBool(v, pos): todo();
		DInt(v, pos): todo();
		DDouble(v, pos): todo();
		DString(v, pos): todo();
		DStringInclude(path, pos): todo();
		DVar(id, pos, eclass): todo();
		DLet(id, value, body, pos, eclass): todo();
		DIf(cond, then, else_, pos, eclass): todo();
		DCall(fn, args, pos, eclass): todo();
		DConstruct(structid, args, pos, eclass): todo();
		DLambda(args, body, pos, eclass): {
			ebody = implicitDExpCasts(tmap, body, eclass);
			wrap(eclass, DLambda(e with body = ebody));
		}
		DRef(value, pos, eclass): todo();
		DField(value, field, pos, eclass): todo();
		DSetMutable(lhs, field, value, pos, eclass): todo();
		DArray(exps, pos, eclass): todo();
		DSequence(exps, pos, eclass): todo();
		DSwitch(value, type, cases, defaultCase, pos, eclass): todo();
		DCast(value, target, pos): todo();
		DDowncast(id, newid, subtype, supereclass, scope, pos, eclass): todo();
		DTyped(value, supertype, pos, eclass): {
			evalue = implicitDExpCasts(tmap, value, eclass);
			wrap(eclass, DTyped(e with value = evalue));
		}
	}
}

makeImplicitCast(tmap : TMap, d : DExp, gotEClass : int, expectedEClass : int) -> DExp {
	// TODO: Do a call for this. We can probably not use DCast,
	// since that requires a DType, which is hard to get from an eclass.
	// Probably just make a DCall to some builtin function with the eclass
	// as argument, and then dexp2bexp can turn that into some BCast construct.
	println("TODO: Add an explicit cast from " + prettyEClass(tmap, gotEClass) + " to " + prettyEClass(tmap, expectedEClass) + " of " + summarizeDExp(d));
	d;
}

isSameEClassInTMap(tmap : TMap, eclass1 : int, eclass2 : int) -> bool {
	// Check if these eclasses correspond to the same type in the eclass world:
	root1 = rootTTypeEClass(tmap, eclass1);
	root2 = rootTTypeEClass(tmap, eclass2);
	root1 == root2 || {
		// We might sometimes have to look at the nodes
		node1 = getUnionMapValue(tmap.tmap, root1);
		node2 = getUnionMapValue(tmap.tmap, root2);
		isSameTNode(tmap, node1, node2);
	}
}
