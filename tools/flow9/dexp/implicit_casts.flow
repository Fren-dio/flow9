import tools/flow9/dexp/dexp;
import tools/flow9/dexp/pretty;
import tools/flow9/types/ugraph/tnode;
import tools/flow9/types/builtin;

export {
	// This introduces explicit casts where we have implicit ones.
	implicitCasts(tmap : TMap, global : DGlobal) -> DGlobal;
}

implicitCasts(tmap : TMap, global : DGlobal) -> DGlobal {
	DGlobal(global with value = implicitDExpCasts(tmap, global.value, global.eclass));
}

implicitDExpCasts(tmap : TMap, e : DExp, expectedEClass : int) -> DExp {
	if (false && expectedEClass != -1) {
		println("We expect " + prettyEClass(tmap, expectedEClass) + " for " + summarizeDExp(e));
	}
	// Adds a cast if we do not have the type that is expected
	wrap = \hasEClass : int, ee : DExp -> {
		// Check if these eclasses correspond to the same type in the eclass world:
		if (expectedEClass == -1 || isSameEClassInTMap(tmap, expectedEClass, hasEClass)) ee
		else {
			// OK, we need a cast.
			makeImplicitCast(tmap, ee, hasEClass, expectedEClass)
		}
	}
	// The same, but with a TType as the interface
	wrapType = \type : TType, ee : DExp -> {
		eclass = findTNode(tmap, type);
		wrap(eclass, ee);
	}
	todo = \ -> {
		println("TODO: Implement implicit casts for this: " + summarizeDExp(e) + " expecting " 
			+ (if (expectedEClass != -1) {
				prettyEClass(tmap, expectedEClass)
			} else "")
		);
		e;
	}
	switch (e) {
		DVoid(pos): wrapType(voidTType, e);
		DBool(v, pos): todo();
		DInt(v, pos): wrapType(intTType, e);
		DDouble(v, pos): todo();
		DString(v, pos): todo();
		DStringInclude(path, pos): todo();
		DVar(id, pos, eclass): {
			wrap(eclass, e);
		}
		DLet(id, value, body, pos, eclass): {
			// TODO: We should probably record the body type
			evalue = implicitDExpCasts(tmap, value, -1);
			ebody = implicitDExpCasts(tmap, body, eclass);
			wrap(eclass, DLet(e with value = evalue, body = ebody));
		}
		DIf(cond, then, else_, pos, eclass): {
			boolEClass = findTNode(tmap, boolTType);
			econd = implicitDExpCasts(tmap, cond, boolEClass);
			ethen = implicitDExpCasts(tmap, then, eclass);
			eelse = implicitDExpCasts(tmap, else_, eclass);
			wrap(eclass, DIf(e with cond = econd, then = ethen, else_ = else_));
		}
		DCall(fn, args, pos, eclass): {
			// TODO: We should maybe record the expected type for the fn and args?
			efn = implicitDExpCasts(tmap, fn, -1);
			eargs = map(args, \a -> {
				implicitDExpCasts(tmap, a, -1);
			});
			wrap(eclass, DCall(e with fn = efn, args = eargs));
		}
		DConstruct(structid, args, pos, eclass): {
			eargs = map(args, \a -> {
				// TODO: Based on the structid, we can find the expected
				// types for each field
				implicitDExpCasts(tmap, a, eclass);
			});
			wrap(eclass, DConstruct(e with args = eargs));
		}
		DLambda(args, body, pos, eclass): {
			// TODO: We should probably extract the return type from the DLambda here
			ebody = implicitDExpCasts(tmap, body, -1);
			wrap(eclass, DLambda(e with body = ebody));
		}
		DRef(value, pos, eclass): todo();
		DField(value, field, pos, eclass): {
			// TODO: Should we record the value type?
			evalue = implicitDExpCasts(tmap, value, -1);
			wrap(eclass, DField(e with value = evalue));
		}
		DSetMutable(lhs, field, value, pos, eclass): todo();
		DArray(exps, pos, eclass): todo();
		DSequence(exps, pos, eclass): {
			voidEclass = findTNode(tmap, voidTType);
			eexps = mapi(exps, \i, ee -> {
				implicitDExpCasts(tmap, ee, if (i + 1 == length(exps)) eclass else voidEclass);
			});
			wrap(eclass, DSequence(e with exps = eexps));
		}
		DSwitch(value, type, cases, defaultCase, pos, eclass): {
			ecases = map(cases, \case -> {
				DCase(case with body = implicitDExpCasts(tmap, case.body, eclass));
			});
			edef = defaultCase ?? {
				Some(implicitDExpCasts(tmap, defaultCase, eclass))
			} : None();
			eswitch = DSwitch(e with cases = ecases, defaultCase = edef);
			wrap(eclass, eswitch);
		}
		DCast(value, target, pos): todo();
		DDowncast(id, newid, subtype, supereclass, scope, pos, eclass): {
			escope = implicitDExpCasts(tmap, scope, eclass);
			wrap(eclass, DDowncast(e with scope = escope));
		}
		DTyped(value, supertype, pos, eclass): {
			evalue = implicitDExpCasts(tmap, value, eclass);
			wrap(eclass, DTyped(e with value = evalue));
		}
	}
}

makeImplicitCast(tmap : TMap, d : DExp, gotEClass : int, expectedEClass : int) -> DExp {
	// Do a call to a special fn __cast__ for this conversion.
	call = DCall(DVar("__cast__", d.pos, gotEClass), [d, DInt(gotEClass, d.pos), DInt(expectedEClass, d.pos)], d.pos, expectedEClass);
	if (true) {
		println("Added an explicit cast from " + prettyEClass(tmap, gotEClass) + " to " + prettyEClass(tmap, expectedEClass) + " of " + summarizeDExp(d));
		// println(call);
	}
	call;
}

isSameEClassInTMap(tmap : TMap, eclass1 : int, eclass2 : int) -> bool {
	// Check if these eclasses correspond to the same type in the eclass world:
	root1 = rootTTypeEClass(tmap, eclass1);
	root2 = rootTTypeEClass(tmap, eclass2);
	root1 == root2 || {
		// We might sometimes have to look at the nodes
		node1 = getUnionMapValue(tmap.tmap, root1);
		node2 = getUnionMapValue(tmap.tmap, root2);
		isSameTNode(tmap, node1, node2);
	}
}
