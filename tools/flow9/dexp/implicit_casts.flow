import tools/flow9/dexp/dexp;
import tools/flow9/dexp/pretty;
import tools/flow9/types/ugraph/tnode;
import tools/flow9/types/builtin;

export {
	// This introduces explicit casts where we have implicit ones.
	implicitCasts(tmap : TMap, global : DGlobal) -> DGlobal;
}

implicitCasts(tmap : TMap, global : DGlobal) -> DGlobal {
	DGlobal(global with value = implicitDExpCasts(tmap, global.value, global.eclass));
}

implicitDExpCasts(tmap : TMap, e : DExp, expectedEClass : int) -> DExp {
	// Adds a cast if we do not have the type that is expected
	wrap = \hasEClass : int, ee : DExp -> {
		root1 = rootTTypeEClass(tmap, expectedEClass);
		root2 = rootTTypeEClass(tmap, hasEClass);
		if (root1 == root2) ee
		else {
			// OK, we need a cast.
			makeImplicitCast(tmap, ee, expectedEClass)
		}
	}
	// The same, but with a TType as the interface
	wrapType = \type : TType, ee : DExp -> {
		eclass = findTNode(tmap, type);
		wrap(eclass, ee);
	}
	todo = \ -> {
		println("Implement implicit casts for this: " + summarizeDExp(e));
		e;
	}
	switch (e) {
		DVoid(pos): wrapType(voidTType, e);
		DBool(v, pos): todo();
		DInt(v, pos): todo();
		DDouble(v, pos): todo();
		DString(v, pos): todo();
		DStringInclude(path, pos): todo();
		DVar(id, pos, eclass): todo();
		DLet(id, value, body, pos, eclass): todo();
		DIf(cond, then, else_, pos, eclass): todo();
		DCall(fn, args, pos, eclass): todo();
		DConstruct(structid, args, pos, eclass): todo();
		DLambda(args, body, pos, eclass): todo();
		DRef(value, pos, eclass): todo();
		DField(value, field, pos, eclass): todo();
		DSetMutable(lhs, field, value, pos, eclass): todo();
		DArray(exps, pos, eclass): todo();
		DSequence(exps, pos, eclass): todo();
		DSwitch(value, type, cases, defaultCase, pos, eclass): todo();
		DCast(value, target, pos): todo();
		DDowncast(id, newid, subtype, supereclass, scope, pos, eclass): todo();
		DTyped(value, supertype, pos, eclass): todo();
	}
}

makeImplicitCast(tmap : TMap, d : DExp, expectedEClass : int) -> DExp {
	// TODO: Do a call for this. We can probably not use DCast,
	// since that requires a DType, which is hard to get from an eclass.
	// Probably just make a DCall to some builtin function with the eclass
	// as argument, and then dexp2bexp can turn that into some BCast construct.
	println("TODO: Add an explicit cast to " + prettyEClass(tmap, expectedEClass) + " of " + summarizeDExp(d));
	d;
}
